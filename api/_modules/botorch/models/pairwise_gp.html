<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>BoTorch · Bayesian Optimization in PyTorch</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Bayesian Optimization in PyTorch"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="BoTorch · Bayesian Optimization in PyTorch"/><meta property="og:type" content="website"/><meta property="og:url" content="https://botorch.org/"/><meta property="og:description" content="Bayesian Optimization in PyTorch"/><meta property="og:image" content="https://botorch.org/img/botorch.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://botorch.org/img/botorch.png"/><link rel="shortcut icon" href="/img/botorch.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-139570076-2', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code_block_buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/code_block_buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/mathjax.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/botorch_logo_lockup_white.png" alt="BoTorch"/><h2 class="headerTitleWithLogo">BoTorch</h2></a><a href="/versions"><h3>stable</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/introduction" target="_self">Docs</a></li><li class=""><a href="/tutorials/" target="_self">Tutorials</a></li><li class=""><a href="/api/" target="_self">API Reference</a></li><li class=""><a href="/docs/papers" target="_self">Papers</a></li><li class=""><a href="https://github.com/pytorch/botorch" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div>
<script type="text/javascript" id="documentation_options" data-url_root="./" src="/js/documentation_options.js"></script>
<script type="text/javascript" src="/js/jquery.js"></script>
<script type="text/javascript" src="/js/underscore.js"></script>
<script type="text/javascript" src="/js/doctools.js"></script>
<script type="text/javascript" src="/js/language_data.js"></script>
<script type="text/javascript" src="/js/searchtools.js"></script>
<div class="sphinx"><div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body" role="main">
<h1>Source code for botorch.models.pairwise_gp</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Copyright (c) Meta Platforms, Inc. and affiliates.</span>
<span class="c1">#</span>
<span class="c1"># This source code is licensed under the MIT license found in the</span>
<span class="c1"># LICENSE file in the root directory of this source tree.</span>

<span class="sa">r</span><span class="sd">"""</span>
<span class="sd">Preference Learning with Gaussian Process</span>

<span class="sd">.. [Chu2005preference]</span>
<span class="sd">    Wei Chu, and Zoubin Ghahramani. Preference learning with Gaussian processes.</span>
<span class="sd">    Proceedings of the 22nd international conference on Machine learning. 2005.</span>

<span class="sd">.. [Brochu2010tutorial]</span>
<span class="sd">    Eric Brochu, Vlad M. Cora, and Nando De Freitas.</span>
<span class="sd">    A tutorial on Bayesian optimization of expensive cost functions,</span>
<span class="sd">    with application to active user modeling and hierarchical reinforcement learning.</span>
<span class="sd">    arXiv preprint arXiv:1012.2599 (2010).</span>
<span class="sd">"""</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">botorch.acquisition.objective</span> <span class="kn">import</span> <span class="n">PosteriorTransform</span>
<span class="kn">from</span> <span class="nn">botorch.exceptions</span> <span class="kn">import</span> <span class="n">UnsupportedError</span>
<span class="kn">from</span> <span class="nn">botorch.models.likelihoods.pairwise</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PairwiseLikelihood</span><span class="p">,</span>
    <span class="n">PairwiseProbitLikelihood</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">botorch.models.model</span> <span class="kn">import</span> <span class="n">FantasizeMixin</span><span class="p">,</span> <span class="n">Model</span>
<span class="kn">from</span> <span class="nn">botorch.models.transforms.input</span> <span class="kn">import</span> <span class="n">InputTransform</span>
<span class="kn">from</span> <span class="nn">botorch.posteriors.gpytorch</span> <span class="kn">import</span> <span class="n">GPyTorchPosterior</span>
<span class="kn">from</span> <span class="nn">botorch.posteriors.posterior</span> <span class="kn">import</span> <span class="n">Posterior</span>
<span class="kn">from</span> <span class="nn">gpytorch</span> <span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span> <span class="nn">gpytorch.constraints</span> <span class="kn">import</span> <span class="n">GreaterThan</span><span class="p">,</span> <span class="n">Interval</span>
<span class="kn">from</span> <span class="nn">gpytorch.distributions.multivariate_normal</span> <span class="kn">import</span> <span class="n">MultivariateNormal</span>
<span class="kn">from</span> <span class="nn">gpytorch.kernels.rbf_kernel</span> <span class="kn">import</span> <span class="n">RBFKernel</span>
<span class="kn">from</span> <span class="nn">gpytorch.kernels.scale_kernel</span> <span class="kn">import</span> <span class="n">ScaleKernel</span>
<span class="kn">from</span> <span class="nn">gpytorch.means.constant_mean</span> <span class="kn">import</span> <span class="n">ConstantMean</span>
<span class="kn">from</span> <span class="nn">gpytorch.mlls</span> <span class="kn">import</span> <span class="n">MarginalLogLikelihood</span>
<span class="kn">from</span> <span class="nn">gpytorch.models.gp</span> <span class="kn">import</span> <span class="n">GP</span>
<span class="kn">from</span> <span class="nn">gpytorch.priors.smoothed_box_prior</span> <span class="kn">import</span> <span class="n">SmoothedBoxPrior</span>
<span class="kn">from</span> <span class="nn">gpytorch.priors.torch_priors</span> <span class="kn">import</span> <span class="n">GammaPrior</span>
<span class="kn">from</span> <span class="nn">linear_operator.operators</span> <span class="kn">import</span> <span class="n">LinearOperator</span><span class="p">,</span> <span class="n">RootLinearOperator</span>
<span class="kn">from</span> <span class="nn">linear_operator.utils.cholesky</span> <span class="kn">import</span> <span class="n">psd_safe_cholesky</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">float32</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">torch.nn.modules.module</span> <span class="kn">import</span> <span class="n">_IncompatibleKeys</span>


<span class="c1"># Why we subclass GP even though it provides no functionality:</span>
<span class="c1"># if this subclassing is removed, we get the following GPyTorch error:</span>
<span class="c1"># "RuntimeError: All MarginalLogLikelihood objects must be given a GP object as</span>
<span class="c1"># a model. If you are using a more complicated model involving a GP, pass the</span>
<span class="c1"># underlying GP object as the model, not a full PyTorch module."</span>
<div class="viewcode-block" id="PairwiseGP"><a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP">[docs]</a><span class="k">class</span> <span class="nc">PairwiseGP</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">FantasizeMixin</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Probit GP for preference learning with Laplace approximation</span>

<span class="sd">    A probit-likelihood GP that learns via pairwise comparison data, using a</span>
<span class="sd">    Laplace approximation of the posterior of the estimated utility values. By</span>
<span class="sd">    default it uses a scaled RBF kernel.</span>

<span class="sd">    Implementation is based on [Chu2005preference]_.</span>
<span class="sd">    Also see [Brochu2010tutorial]_ for additional reference.</span>

<span class="sd">    Note that in [Chu2005preference]_ the likelihood of a pairwise comparison</span>
<span class="sd">    is :math:`\left(\frac{f(x_1) - f(x_2)}{\sqrt{2}\sigma}\right)`, i.e. a scale is</span>
<span class="sd">    used in the denominator. To maintain consistency with usage of kernels</span>
<span class="sd">    elsewhere in BoTorch, we instead do not include :math:`\sigma` in the code</span>
<span class="sd">    (implicitly setting it to 1) and use ScaleKernel to scale the function.</span>

<span class="sd">    In the example below, the user/decision maker has stated that they prefer</span>
<span class="sd">    the first item over the second item and the third item over the second item,</span>
<span class="sd">    generating comparisons [0, 1] and [2, 1].</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from botorch.models import PairwiseGP</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; datapoints = torch.Tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">        &gt;&gt;&gt; comparisons = torch.Tensor([[0, 1], [2, 1]])</span>
<span class="sd">        &gt;&gt;&gt; model = PairwiseGP(datapoints, comparisons)</span>
<span class="sd">    """</span>

    <span class="n">_buffer_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">"datapoints"</span><span class="p">,</span>
        <span class="s2">"comparisons"</span><span class="p">,</span>
        <span class="s2">"D"</span><span class="p">,</span>
        <span class="s2">"DT"</span><span class="p">,</span>
        <span class="s2">"utility"</span><span class="p">,</span>
        <span class="s2">"covar_chol"</span><span class="p">,</span>
        <span class="s2">"likelihood_hess"</span><span class="p">,</span>
        <span class="s2">"hlcov_eye"</span><span class="p">,</span>
        <span class="s2">"covar"</span><span class="p">,</span>
        <span class="s2">"covar_inv"</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">comparisons</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">likelihood</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PairwiseLikelihood</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">covar_module</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ScaleKernel</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">input_transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InputTransform</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Args:</span>
<span class="sd">            datapoints: A `batch_shape x n x d` tensor of training features.</span>
<span class="sd">            comparisons: A `batch_shape x m x 2` training comparisons;</span>
<span class="sd">                comparisons[i] is a noisy indicator suggesting the utility value</span>
<span class="sd">                of comparisons[i, 0]-th is greater than comparisons[i, 1]-th.</span>
<span class="sd">            likelihood: A PairwiseLikelihood.</span>
<span class="sd">            covar_module: Covariance module.</span>
<span class="sd">            input_transform: An input transform that is applied in the model's</span>
<span class="sd">                forward pass.</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">input_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_transform</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="c1"># input transformation is applied in set_train_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_transform</span> <span class="o">=</span> <span class="n">input_transform</span>

        <span class="c1"># Compatibility variables with fit_gpytorch_*: Dummy likelihood</span>
        <span class="c1"># Likelihood is tightly tied with this model and</span>
        <span class="c1"># it doesn't make much sense to keep it separate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">PairwiseProbitLikelihood</span><span class="p">()</span> <span class="k">if</span> <span class="n">likelihood</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">likelihood</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">train_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_targets</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utility</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pred_cov_fac_need_update</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># See set_train_data for additional compatibility variables.</span>
        <span class="c1"># Not that the datapoints here are not transformed even if input_transform</span>
        <span class="c1"># is not None to avoid double transformation during model fitting.</span>
        <span class="c1"># self.transform_inputs is called in `forward`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_train_data</span><span class="p">(</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">comparisons</span><span class="p">,</span> <span class="n">update_model</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Set optional parameters</span>
        <span class="c1"># Explicitly set jitter for numerical stability in psd_safe_cholesky</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jitter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"jitter"</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span>
        <span class="c1"># Stopping creteria in scipy.optimize.fsolve used to find f_map in _update()</span>
        <span class="c1"># If None, set to 1e-6 by default in _update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xtol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"xtol"</span><span class="p">)</span>
        <span class="c1"># The maximum number of calls to the function in scipy.optimize.fsolve</span>
        <span class="c1"># If None, set to 100 by default in _update</span>
        <span class="c1"># If zero, then 100*(N+1) is used by default by fsolve;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxfev</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"maxfev"</span><span class="p">)</span>

        <span class="c1"># Set hyperparameters</span>
        <span class="c1"># Do not set the batch_shape explicitly so mean_module can operate in both mode</span>
        <span class="c1"># once fsolve used in _update can run in batch mode, we should explicitly set</span>
        <span class="c1"># the bacth shape here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_module</span> <span class="o">=</span> <span class="n">ConstantMean</span><span class="p">()</span>
        <span class="c1"># Do not optimize constant mean prior</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_module</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
            <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># set covariance module</span>
        <span class="c1"># the default outputscale here is only a rule of thumb, meant to keep</span>
        <span class="c1"># estimates away from scale value that would make Phi(f(x)) saturate</span>
        <span class="c1"># at 0 or 1</span>
        <span class="k">if</span> <span class="n">covar_module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">os_lb</span><span class="p">,</span> <span class="n">os_ub</span> <span class="o">=</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span>
            <span class="n">ls_prior</span> <span class="o">=</span> <span class="n">GammaPrior</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="n">ls_prior_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ls_prior</span><span class="o">.</span><span class="n">concentration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">ls_prior</span><span class="o">.</span><span class="n">rate</span>
            <span class="n">covar_module</span> <span class="o">=</span> <span class="n">ScaleKernel</span><span class="p">(</span>
                <span class="n">RBFKernel</span><span class="p">(</span>
                    <span class="n">batch_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_shape</span><span class="p">,</span>
                    <span class="n">ard_num_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
                    <span class="n">lengthscale_prior</span><span class="o">=</span><span class="n">ls_prior</span><span class="p">,</span>
                    <span class="n">lengthscale_constraint</span><span class="o">=</span><span class="n">GreaterThan</span><span class="p">(</span>
                        <span class="n">lower_bound</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_value</span><span class="o">=</span><span class="n">ls_prior_mode</span>
                    <span class="p">),</span>
                <span class="p">),</span>
                <span class="n">outputscale_prior</span><span class="o">=</span><span class="n">SmoothedBoxPrior</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">os_lb</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">os_ub</span><span class="p">),</span>
                <span class="c1"># make sure we won't get extreme values for the output scale</span>
                <span class="n">outputscale_constraint</span><span class="o">=</span><span class="n">Interval</span><span class="p">(</span>
                    <span class="n">lower_bound</span><span class="o">=</span><span class="n">os_lb</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>
                    <span class="n">upper_bound</span><span class="o">=</span><span class="n">os_ub</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">,</span>
                    <span class="n">initial_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">covar_module</span><span class="p">,</span> <span class="n">ScaleKernel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsupportedError</span><span class="p">(</span><span class="s2">"PairwiseGP must be used with a ScaleKernel."</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span> <span class="o">=</span> <span class="n">covar_module</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will store temporary results for warm-starting</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="c1"># Find f_map for initial parameters with transformed datapoints</span>
            <span class="n">transformed_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PairwiseGP</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">"datapoints"</span><span class="p">,</span>
            <span class="s2">"comparisons"</span><span class="p">,</span>
            <span class="s2">"covar"</span><span class="p">,</span>
            <span class="s2">"covar_inv"</span><span class="p">,</span>
            <span class="s2">"covar_chol"</span><span class="p">,</span>
            <span class="s2">"likelihood_hess"</span><span class="p">,</span>
            <span class="s2">"utility"</span><span class="p">,</span>
            <span class="s2">"hlcov_eye"</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">):</span>
            <span class="c1"># Temporarily remove non-leaf tensors so that pytorch allows deepcopy</span>
            <span class="n">old_attr</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="n">old_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">new_model</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
            <span class="c1"># now set things back</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">old_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">new_model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dcp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span>
            <span class="c1"># make sure we don't fall into the infinite recursive loop</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">new_model</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span> <span class="o">=</span> <span class="n">dcp</span>
            <span class="k">return</span> <span class="n">new_model</span>

    <span class="k">def</span> <span class="nf">_scaled_psd_safe_cholesky</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">jitter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""scale M by 1/outputscale before cholesky for better numerical stability"""</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span><span class="o">.</span><span class="n">outputscale</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">scale</span>
        <span class="n">chol</span> <span class="o">=</span> <span class="n">psd_safe_cholesky</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="n">jitter</span><span class="p">)</span>
        <span class="n">chol</span> <span class="o">=</span> <span class="n">chol</span> <span class="o">*</span> <span class="n">scale</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">chol</span>

    <span class="k">def</span> <span class="nf">_has_no_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Return true if the model does not have both datapoints and comparisons"""</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_covar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">X2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">LinearOperator</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Calculate the covariance matrix given two sets of datapoints"""</span>
        <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">covar</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_update_covar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Update values derived from the data and hyperparameters</span>

<span class="sd">        covar, covar_chol, and covar_inv will be of shape batch_shape x n x n</span>

<span class="sd">        Args:</span>
<span class="sd">            datapoints: (Transformed) datapoints for finding f_max</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_covar</span><span class="p">(</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_psd_safe_cholesky</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covar</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_jitter</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_inv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cholesky_inverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prior_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">LinearOperator</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Return point prediction using prior only</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_size x n' x d`-dim Tensor at which to evaluate prior</span>

<span class="sd">        Returns:</span>
<span class="sd">            Prior mean prediction</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_module</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prior_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Predict utility based on prior info only</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_size x n' x d`-dim Tensor at which to evaluate prior</span>

<span class="sd">        Returns:</span>
<span class="sd">            pred_mean: predictive mean</span>
<span class="sd">            pred_covar: predictive covariance</span>
<span class="sd">        """</span>
        <span class="n">pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_mean</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">pred_covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_covar</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_mean</span><span class="p">,</span> <span class="n">pred_covar</span>

    <span class="k">def</span> <span class="nf">_grad_posterior_f</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">utility</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">D</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">DT</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">covar_chol</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">covar_inv</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">ret_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Compute the gradient of S loss wrt to f/utility in [Chu2005preference]_.</span>

<span class="sd">        For finding f_map, which is negative of the log posterior, i.e., -log(p(f|D))</span>
<span class="sd">        Derivative of (10) in [Chu2005preference]_.</span>
<span class="sd">        Also see [Brochu2010tutorial]_ page 26. This is needed for estimating f_map.</span>

<span class="sd">        Args:</span>
<span class="sd">            utility: A Tensor of shape `batch_size x n`</span>
<span class="sd">            datapoints: A Tensor of shape `batch_size x n x d` as in self.datapoints</span>
<span class="sd">            D: A Tensor of shape `batch_size x m x n` as in self.D</span>
<span class="sd">            DT: Transpose of D. A Tensor of shape `batch_size x n x m` as in self.DT</span>
<span class="sd">            covar_chol: A Tensor of shape `batch_size x n x n`, as in self.covar_chol</span>
<span class="sd">            covar_inv: A Tensor of shape `batch_size x n x n`, as in self.covar_inv</span>
<span class="sd">            ret_np: return a numpy array if true, otherwise a Tensor</span>
<span class="sd">        """</span>
        <span class="n">prior_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_mean</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ret_np</span><span class="p">:</span>
            <span class="n">utility</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">utility</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">prior_mean</span> <span class="o">=</span> <span class="n">prior_mean</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">negative_log_gradient_sum</span><span class="p">(</span><span class="n">utility</span><span class="o">=</span><span class="n">utility</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>

        <span class="c1"># g_ = covar_inv x (utility - pred_prior)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">utility</span> <span class="o">-</span> <span class="n">prior_mean</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">covar_chol</span><span class="p">)</span>
        <span class="n">g_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">covar_chol</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g_</span> <span class="o">+</span> <span class="n">b</span>

        <span class="k">if</span> <span class="n">ret_np</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_hess_posterior_f</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">utility</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">D</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">DT</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">covar_chol</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">covar_inv</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">ret_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Compute the hessian of S loss wrt utility for finding f_map.</span>

<span class="sd">        which is negative of the log posterior, i.e., -log(p(f|D))</span>
<span class="sd">        Following [Chu2005preference]_ section 2.2.1.</span>
<span class="sd">        This is needed for estimating f_map</span>

<span class="sd">        Args:</span>
<span class="sd">            utility: A Tensor of shape `batch_size x n`</span>
<span class="sd">            datapoints: A Tensor of shape `batch_size x n x d` as in self.datapoints</span>
<span class="sd">            D: A Tensor of shape `batch_size x m x n` as in self.D</span>
<span class="sd">            DT: Transpose of D. A Tensor of shape `batch_size x n x m` as in self.DT</span>
<span class="sd">            covar_chol: A Tensor of shape `batch_size x n x n`, as in self.covar_chol</span>
<span class="sd">            covar_inv: A Tensor of shape `batch_size x n x n`, as in self.covar_inv</span>
<span class="sd">            ret_np: return a numpy array if true, otherwise a Tensor</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">ret_np</span><span class="p">:</span>
            <span class="n">utility</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">utility</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">negative_log_hessian_sum</span><span class="p">(</span><span class="n">utility</span><span class="o">=</span><span class="n">utility</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="n">hl</span> <span class="o">+</span> <span class="n">covar_inv</span>
        <span class="k">return</span> <span class="n">hess</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">if</span> <span class="n">ret_np</span> <span class="k">else</span> <span class="n">hess</span>

    <span class="k">def</span> <span class="nf">_update_utility_derived_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Calculate utility-derived values not needed during optimization</span>

<span class="sd">        Using subsitution method for better numerical stability</span>
<span class="sd">        Let `pred_cov_fac = (covar + hl^-1)`, which is needed for calculate</span>
<span class="sd">        predictive covariance = `K - k.T @ pred_cov_fac^-1 @ k`</span>
<span class="sd">        (Also see posterior mode in `forward`)</span>
<span class="sd">        Instead of inverting `pred_cov_fac`, let `hlcov_eye = (hl @ covar + I)`</span>
<span class="sd">        Then we can obtain `pred_cov_fac^-1 @ k` by solving for p in</span>
<span class="sd">        `(hl @ k) p = hlcov_eye`</span>
<span class="sd">        `hlcov_eye p = hl @ k`</span>
<span class="sd">        """</span>
        <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span>  <span class="c1"># "C" from page 27, [Brochu2010tutorial]_</span>
        <span class="n">hlcov</span> <span class="o">=</span> <span class="n">hl</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span>
            <span class="n">hlcov</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">hlcov</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hlcov_eye</span> <span class="o">=</span> <span class="n">hlcov</span> <span class="o">+</span> <span class="n">eye</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pred_cov_fac_need_update</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Update the model by updating the covar matrix and MAP utility values</span>

<span class="sd">        Update the model by</span>
<span class="sd">        1. Re-evaluating the covar matrix as the data or hyperparams may have changed</span>
<span class="sd">        2. Approximating maximum a posteriori of the utility function f using fsolve</span>

<span class="sd">        Should be called after data or hyperparameters are changed to update</span>
<span class="sd">        f_map and related values</span>

<span class="sd">        self._xtol and self._maxfev are passed to fsolve as xtol and maxfev</span>
<span class="sd">        to control stopping criteria</span>

<span class="sd">        Args:</span>
<span class="sd">            datapoints: (transformed) datapoints for finding f_max</span>
<span class="sd">        """</span>

        <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xtol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xtol</span>
        <span class="n">maxfev</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxfev</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxfev</span>

        <span class="c1"># Using the latest param for covariance before calculating f_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_covar</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>

        <span class="c1"># scipy newton raphson</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="c1"># warm start</span>
            <span class="n">init_x0_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_shape</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">init_x0_size</span><span class="p">:</span>
                <span class="n">sqrt_scale</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span><span class="o">.</span><span class="n">outputscale</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="c1"># initialize x0 using std normal but clip by 3 std to keep it bounded</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">init_x0_size</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="c1"># scale x0 to be on roughly the right scale</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">*</span> <span class="n">sqrt_scale</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># batch mode, do optimize.fsolve sequentially on CPU</span>
                <span class="c1"># TODO: enable vectorization/parallelization here</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="n">dp_v</span> <span class="o">=</span> <span class="n">datapoints</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">D_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">DT_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DT</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">ch_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">ci_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_inv</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">fsolve_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">D_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DT_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ch_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ci_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">"ignore"</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span>
                            <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_grad_posterior_f</span><span class="p">,</span>
                            <span class="n">fprime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hess_posterior_f</span><span class="p">,</span>
                            <span class="n">xtol</span><span class="o">=</span><span class="n">xtol</span><span class="p">,</span>
                            <span class="n">maxfev</span><span class="o">=</span><span class="n">maxfev</span><span class="p">,</span>
                            <span class="n">args</span><span class="o">=</span><span class="n">fsolve_args</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">init_x0_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># fsolve only works on CPU</span>
                <span class="n">fsolve_args</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">datapoints</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">DT</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">covar_inv</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
                    <span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">"ignore"</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span>
                        <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
                        <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_grad_posterior_f</span><span class="p">,</span>
                        <span class="n">fprime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hess_posterior_f</span><span class="p">,</span>
                        <span class="n">xtol</span><span class="o">=</span><span class="n">xtol</span><span class="p">,</span>
                        <span class="n">maxfev</span><span class="o">=</span><span class="n">maxfev</span><span class="p">,</span>
                        <span class="n">args</span><span class="o">=</span><span class="n">fsolve_args</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># save for warm-starting</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># To perform hyperparameter optimization, this need to be recalculated</span>
        <span class="c1"># when calling forward() in order to obtain correct gradients</span>
        <span class="c1"># self.likelihood_hess is updated here is for the rare case where we</span>
        <span class="c1"># do not want to call forward()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">negative_log_hessian_sum</span><span class="p">(</span>
            <span class="n">utility</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span>
        <span class="p">)</span>

        <span class="c1"># Lazy update hlcov_eye, which is used in calculating posterior during training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred_cov_fac_need_update</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># fill in dummy values for hlcov_eye so that load_state_dict can function</span>
        <span class="n">hlcov_eye_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hlcov_eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">hlcov_eye_size</span><span class="p">)</span>

        <span class="c1"># Take two newton step on the posterior MAP point to fill</span>
        <span class="c1"># in gradients for pytorch. Using 2 instead of 1 since empirically sometimes</span>
        <span class="c1"># the first step results in gradients in the order of 1e-7 while the 2nd step</span>
        <span class="c1"># allows it go down further to the order of 1e-12 and stay there.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utility</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_util_newton_updates</span><span class="p">(</span>
            <span class="n">datapoints</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_transform_batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">X_new</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">"""Transform X and X_new into the same shape</span>

<span class="sd">        Transform the batch shape of X to be compatible</span>
<span class="sd">        with `X_new` to calculate the posterior.</span>
<span class="sd">        If X has the same batch size as `X_new`, return it as is.</span>
<span class="sd">        If one is in batch mode and the other one is not, convert both</span>
<span class="sd">        into batch mode.</span>
<span class="sd">        If both are in batch mode, this will only work if X_batch_shape</span>
<span class="sd">        can propagate to X_new_batch_shape</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_shape x q x d`-dim or `(1 x) q x d`-dim Tensor</span>
<span class="sd">            X_new: A `batch_shape x q x d`-dim Tensor</span>

<span class="sd">        Returns:</span>
<span class="sd">            Transformed X and X_new pair</span>
<span class="sd">        """</span>
        <span class="n">X_bs</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># X batch shape</span>
        <span class="n">X_new_bs</span> <span class="o">=</span> <span class="n">X_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># X_new batch shape</span>
        <span class="k">if</span> <span class="n">X_new_bs</span> <span class="o">==</span> <span class="n">X_bs</span><span class="p">:</span>
            <span class="c1"># if batch shapes match, there's no need to transform</span>
            <span class="c1"># X_new may or may not have batch_shape dimensions</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">X_new</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_new_bs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_bs</span><span class="p">):</span>
            <span class="c1"># if X_new has fewer dimension, try to expand it to X's shape</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">X_new</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">X_bs</span> <span class="o">+</span> <span class="n">X_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if X has fewer dimension, try to expand it to X_new's shape</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">X_new_bs</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">X_new</span>

    <span class="k">def</span> <span class="nf">_util_newton_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Make `max_iter` newton updates on utility.</span>

<span class="sd">        This is used in `forward` to calculate and fill in gradient into tensors.</span>
<span class="sd">        Instead of doing utility -= H^-1 @ g, use substition method.</span>
<span class="sd">        See more explanation in _update_utility_derived_values.</span>
<span class="sd">        By default only need to run one iteration just to fill the the gradients.</span>

<span class="sd">        Args:</span>
<span class="sd">            dp: (Transformed) datapoints.</span>
<span class="sd">            x0: A `batch_size x n` dimension tensor, initial values.</span>
<span class="sd">            max_iter: Max number of iterations.</span>
<span class="sd">            xtol: Stop creteria. If `None`, do not stop until</span>
<span class="sd">                finishing `max_iter` updates.</span>
<span class="sd">        """</span>
        <span class="n">xtol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">"-Inf"</span><span class="p">)</span> <span class="k">if</span> <span class="n">xtol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">xtol</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">DT</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ci</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">DT</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covar_inv</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">"Inf"</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_iter</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">xtol</span><span class="p">:</span>
            <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">negative_log_hessian_sum</span><span class="p">(</span><span class="n">utility</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span> <span class="o">=</span> <span class="n">hl</span>
            <span class="n">cov_hl</span> <span class="o">=</span> <span class="n">covar</span> <span class="o">@</span> <span class="n">hl</span>
            <span class="k">if</span> <span class="n">eye</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                        <span class="n">cov_hl</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">cov_hl</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cov_hl</span><span class="o">.</span><span class="n">dtype</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">cov_hl</span> <span class="o">=</span> <span class="n">cov_hl</span> <span class="o">+</span> <span class="n">eye</span>  <span class="c1"># add 1 to cov_hl</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grad_posterior_f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dp</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">DT</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ci</span><span class="p">)</span>
            <span class="n">cov_g</span> <span class="o">=</span> <span class="n">covar</span> <span class="o">@</span> <span class="n">g</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">x_update</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">cov_hl</span><span class="p">,</span> <span class="n">cov_g</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">x_next</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x_update</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_next</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x_next</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">_check_strict_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">t_inputs</span><span class="p">,</span> <span class="n">target_or_inputs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">input_</span><span class="p">,</span> <span class="n">t_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t_inputs</span> <span class="ow">or</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)):</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">"shape"</span><span class="p">,</span> <span class="s2">"dtype"</span><span class="p">,</span> <span class="s2">"device"</span><span class="p">}:</span>
                <span class="n">expected_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t_input</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">found_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">expected_attr</span> <span class="o">!=</span> <span class="n">found_attr</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">"Cannot modify </span><span class="si">{attr}</span><span class="s2"> of </span><span class="si">{t_or_i}</span><span class="s2"> "</span>
                        <span class="s2">"(expected </span><span class="si">{e_attr}</span><span class="s2">, found </span><span class="si">{f_attr}</span><span class="s2">)."</span>
                    <span class="p">)</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span>
                        <span class="n">e_attr</span><span class="o">=</span><span class="n">expected_attr</span><span class="p">,</span>
                        <span class="n">f_attr</span><span class="o">=</span><span class="n">found_attr</span><span class="p">,</span>
                        <span class="n">t_or_i</span><span class="o">=</span><span class="n">target_or_inputs</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># ============== public APIs ==============</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""The number of outputs of the model."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_outputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""The batch shape of the model.</span>

<span class="sd">        This is a batch shape from an I/O perspective, independent of the internal</span>
<span class="sd">        representation of the model (as e.g. in BatchedMultiOutputGPyTorchModel).</span>
<span class="sd">        For a model with `m` outputs, a `test_batch_shape x q x d`-shaped input `X`</span>
<span class="sd">        to the `posterior` method returns a Posterior object over an output of</span>
<span class="sd">        shape `broadcast(test_batch_shape, model.batch_shape) x q x m`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># this could happen in prior mode</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

<div class="viewcode-block" id="PairwiseGP.set_train_data"><a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.set_train_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_train_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">comparisons</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">update_model</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Set datapoints and comparisons and update model properties if needed</span>

<span class="sd">        Args:</span>
<span class="sd">            datapoints: A `batch_shape x n x d` dimension tensor X. If there are input</span>
<span class="sd">                transformations, assume the datapoints are not transformed</span>
<span class="sd">            comparisons: A tensor of size `batch_shape x m x 2`. (i, j) means</span>
<span class="sd">                f_i is preferred over f_j.</span>
<span class="sd">            strict: `strict` argument as in gpytorch.models.exact_gp for compatibility</span>
<span class="sd">                when using fit_gpytorch_model with input_transform.</span>
<span class="sd">            update_model: True if we want to refit the model (see _update) after</span>
<span class="sd">                re-setting the data.</span>
<span class="sd">        """</span>
        <span class="c1"># When datapoints and/or comparisons are None, we are constructing</span>
        <span class="c1"># a prior-only model</span>
        <span class="k">if</span> <span class="n">datapoints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">comparisons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># following gpytorch.models.exact_gp.set_train_data</span>
        <span class="k">if</span> <span class="n">datapoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">datapoints</span><span class="p">):</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">datapoints</span><span class="p">,)</span>

            <span class="n">inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">input_</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">input_</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">input_</span>
                <span class="k">for</span> <span class="n">input_</span> <span class="ow">in</span> <span class="n">inputs</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_strict_input</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_inputs</span><span class="p">,</span> <span class="s2">"inputs"</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Compatibility variables with fit_gpytorch_*</span>
            <span class="c1"># alias for datapoints ("train_inputs")</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_inputs</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="k">if</span> <span class="n">comparisons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_strict_input</span><span class="p">([</span><span class="n">comparisons</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_targets</span><span class="p">],</span> <span class="s2">"targets"</span><span class="p">)</span>

            <span class="c1"># convert to long so that it can be used as index and</span>
            <span class="c1"># compatible with Tensor.scatter_</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">comparisons</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
            <span class="c1"># Compatibility variables with fit_gpytorch_*</span>
            <span class="c1"># alias for comparisons ("train_targets" here)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span>

        <span class="c1"># Compatibility variables with optimize_acqf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_outputs</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 1 latent value output per observation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># feature dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># num datapoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># num pairwise comparisons</span>
        <span class="c1"># D is batch_size x m x n or num_comparison x num_datapoints.</span>
        <span class="c1"># D_k_i is the s_k(x_i) value as in equation (6) in [Chu2005preference]_</span>
        <span class="c1"># D will usually be very sparse as well</span>
        <span class="c1"># TODO swap out scatter_ so that comparisons could be int instead of long</span>
        <span class="c1"># TODO: make D a sparse matrix once pytorch has better support for</span>
        <span class="c1">#       sparse tensors</span>
        <span class="n">D_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">D_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>
        <span class="n">comp_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sub_D</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)):</span>
            <span class="n">sub_D</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp_view</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sub_D</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp_view</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">update_model</span><span class="p">:</span>
            <span class="n">transformed_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">)</span></div>

<div class="viewcode-block" id="PairwiseGP.load_state_dict"><a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.load_state_dict">[docs]</a>    <span class="k">def</span> <span class="nf">load_state_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IncompatibleKeys</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Removes data related buffers from the `state_dict` and calls</span>
<span class="sd">        `super().load_state_dict` with `strict=False`.</span>

<span class="sd">        Args:</span>
<span class="sd">            state_dict: The state dict.</span>
<span class="sd">            strict: Boolean specifying whether or not given and instance-bound</span>
<span class="sd">                state_dicts should have identical keys. Only implemented for</span>
<span class="sd">                `strict=False` since buffers will filters out when calling</span>
<span class="sd">                `_load_from_state_dict`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A named tuple `_IncompatibleKeys`, containing the `missing_keys`</span>
<span class="sd">            and `unexpected_keys`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedError</span><span class="p">(</span><span class="s2">"Passing strict=True is not supported."</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="o">=</span><span class="n">state_dict</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_load_from_state_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">local_metadata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">missing_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">unexpected_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">error_msgs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_load_from_state_dict</span><span class="p">(</span>
            <span class="n">state_dict</span><span class="o">=</span><span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_names</span>
            <span class="p">},</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
            <span class="n">local_metadata</span><span class="o">=</span><span class="n">local_metadata</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">missing_keys</span><span class="o">=</span><span class="n">missing_keys</span><span class="p">,</span>
            <span class="n">unexpected_keys</span><span class="o">=</span><span class="n">unexpected_keys</span><span class="p">,</span>
            <span class="n">error_msgs</span><span class="o">=</span><span class="n">error_msgs</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PairwiseGP.forward"><a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MultivariateNormal</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Calculate a posterior or prior prediction.</span>

<span class="sd">        During training mode, forward implemented solely for gradient-based</span>
<span class="sd">        hyperparam opt. Essentially what it does is to re-calculate the utility</span>
<span class="sd">        f using its analytical form at f_map so that we are able to obtain</span>
<span class="sd">        gradients of the hyperparameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            datapoints: A `batch_shape x n x d` Tensor,</span>
<span class="sd">                should be the same as self.datapoints during training</span>

<span class="sd">        Returns:</span>
<span class="sd">            A MultivariateNormal object, being one of the followings:</span>
<span class="sd">                1. Posterior centered at MAP points for training data (training mode)</span>
<span class="sd">                2. Prior predictions (prior mode)</span>
<span class="sd">                3. Predictive posterior (eval mode)</span>
<span class="sd">        """</span>
        <span class="c1"># Training mode: optimizing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_no_data</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">"datapoints and comparisons cannot be None in training mode. "</span>
                    <span class="s2">"Call .eval() for prior predictions, "</span>
                    <span class="s2">"or call .set_train_data() to add training data."</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">datapoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Must train on training data"</span><span class="p">)</span>

            <span class="n">transformed_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>

            <span class="c1"># We pass in the untransformed datapoints into set_train_data</span>
            <span class="c1"># as we will be setting self.datapoints as the untransformed datapoints</span>
            <span class="c1"># self.transform_inputs will be called inside before calling _update()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_train_data</span><span class="p">(</span><span class="n">datapoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">update_model</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span>
            <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar</span>
            <span class="c1"># Apply matrix inversion lemma on eq. in page 27 of [Brochu2010tutorial]_</span>
            <span class="c1"># (A + B)^-1 = A^-1 - A^-1 @ (I + BA^-1)^-1 @ BA^-1</span>
            <span class="c1"># where A = covar_inv, B = hl</span>
            <span class="n">hl_cov</span> <span class="o">=</span> <span class="n">hl</span> <span class="o">@</span> <span class="n">covar</span>
            <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span>
                <span class="n">hl_cov</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">hl_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">hl_cov_I</span> <span class="o">=</span> <span class="n">hl_cov</span> <span class="o">+</span> <span class="n">eye</span>  <span class="c1"># add I to hl_cov</span>
            <span class="n">train_covar_map</span> <span class="o">=</span> <span class="n">covar</span> <span class="o">-</span> <span class="n">covar</span> <span class="o">@</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">hl_cov_I</span><span class="p">,</span> <span class="n">hl_cov</span><span class="p">)</span>
            <span class="n">output_mean</span><span class="p">,</span> <span class="n">output_covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility</span><span class="p">,</span> <span class="n">train_covar_map</span>

        <span class="c1"># Prior mode</span>
        <span class="k">elif</span> <span class="n">settings</span><span class="o">.</span><span class="n">prior_mode</span><span class="o">.</span><span class="n">on</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_no_data</span><span class="p">():</span>
            <span class="n">transformed_new_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="c1"># if we don't have any data yet, use prior GP to make predictions</span>
            <span class="n">output_mean</span><span class="p">,</span> <span class="n">output_covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_predict</span><span class="p">(</span><span class="n">transformed_new_dp</span><span class="p">)</span>

        <span class="c1"># Posterior mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformed_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="n">transformed_new_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">)</span>

            <span class="c1"># self.utility might be None if exception was raised and _update</span>
            <span class="c1"># was failed to be called during hyperparameter optimization</span>
            <span class="c1"># procedures (e.g., fit_gpytorch_mll_scipy)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_cov_fac_need_update</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_utility_derived_values</span><span class="p">()</span>

            <span class="n">X</span><span class="p">,</span> <span class="n">X_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_batch_shape</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">,</span> <span class="n">transformed_new_dp</span><span class="p">)</span>
            <span class="n">covar_chol</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
            <span class="n">hl</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
            <span class="n">hlcov_eye</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlcov_eye</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>

            <span class="c1"># otherwise compute predictive mean and covariance</span>
            <span class="n">covar_xnew_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_covar</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">covar_x_xnew</span> <span class="o">=</span> <span class="n">covar_xnew_x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">covar_xnew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_covar</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_mean</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

            <span class="n">covar_inv_p</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">covar_chol</span><span class="p">)</span>
            <span class="n">pred_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">covar_xnew_x</span> <span class="o">@</span> <span class="n">covar_inv_p</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pred_mean</span> <span class="o">=</span> <span class="n">pred_mean</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_mean</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

            <span class="c1"># [Brochu2010tutorial]_ page 27</span>
            <span class="c1"># Preictive covariance fatcor: hlcov_eye = (K + C^-1)</span>
            <span class="c1"># fac = (K + C^-1)^-1 @ k = pred_cov_fac_inv @ covar_x_xnew</span>
            <span class="c1"># used substitution method here to calculate fac</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">hlcov_eye</span><span class="p">,</span> <span class="n">hl</span> <span class="o">@</span> <span class="n">covar_x_xnew</span><span class="p">)</span>
            <span class="n">pred_covar</span> <span class="o">=</span> <span class="n">covar_xnew</span> <span class="o">-</span> <span class="p">(</span><span class="n">covar_xnew_x</span> <span class="o">@</span> <span class="n">fac</span><span class="p">)</span>

            <span class="n">output_mean</span><span class="p">,</span> <span class="n">output_covar</span> <span class="o">=</span> <span class="n">pred_mean</span><span class="p">,</span> <span class="n">pred_covar</span>

        <span class="n">post</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span>
            <span class="n">mean</span><span class="o">=</span><span class="n">output_mean</span><span class="p">,</span>
            <span class="c1"># output_covar is sometimes non-PSD</span>
            <span class="c1"># perform a cholesky decomposition to check and amend</span>
            <span class="n">covariance_matrix</span><span class="o">=</span><span class="n">RootLinearOperator</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scaled_psd_safe_cholesky</span><span class="p">(</span><span class="n">output_covar</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_jitter</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">post</span></div>

    <span class="c1"># ============== botorch.models.model.Model interfaces ==============</span>
<div class="viewcode-block" id="PairwiseGP.posterior"><a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.posterior">[docs]</a>    <span class="k">def</span> <span class="nf">posterior</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">output_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">observation_noise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">posterior_transform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PosteriorTransform</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Posterior</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Computes the posterior over model outputs at the provided points.</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_shape x q x d`-dim Tensor, where `d` is the dimension</span>
<span class="sd">                of the feature space and `q` is the number of points considered jointly.</span>
<span class="sd">            output_indices: As defined in parent Model class, not used for this model.</span>
<span class="sd">            observation_noise: Ignored (since noise is not identifiable from scale</span>
<span class="sd">                in probit models).</span>
<span class="sd">            posterior_transform: An optional PosteriorTransform.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `Posterior` object, representing joint</span>
<span class="sd">                distributions over `q` points.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>  <span class="c1"># make sure model is in eval mode</span>

        <span class="k">if</span> <span class="n">output_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">"output_indices is not None. PairwiseGP should not be a"</span>
                <span class="s2">"multi-output model."</span>
            <span class="p">)</span>

        <span class="n">post</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">posterior</span> <span class="o">=</span> <span class="n">GPyTorchPosterior</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">posterior_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">posterior_transform</span><span class="p">(</span><span class="n">posterior</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">posterior</span></div>

<div class="viewcode-block" id="PairwiseGP.condition_on_observations"><a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.condition_on_observations">[docs]</a>    <span class="k">def</span> <span class="nf">condition_on_observations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Condition the model on new observations.</span>

<span class="sd">        Note that unlike other BoTorch models, PairwiseGP requires Y to be</span>
<span class="sd">        pairwise comparisons</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_shape x n x d` dimension tensor X</span>
<span class="sd">            Y: A tensor of size `batch_shape x m x 2`. (i, j) means</span>
<span class="sd">                f_i is preferred over f_j</span>

<span class="sd">        Returns:</span>
<span class="sd">            A (deepcopied) `Model` object of the same type, representing the</span>
<span class="sd">            original model conditioned on the new observations `(X, Y)`.</span>
<span class="sd">        """</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_no_data</span><span class="p">():</span>
            <span class="c1"># If the model previously has no data, set X and Y as the data directly</span>
            <span class="n">new_model</span><span class="o">.</span><span class="n">set_train_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">update_model</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Can only condition on pairwise comparisons instead of the directly</span>
            <span class="c1"># observed values. Raise a RuntimeError if Y is not a tensor presenting</span>
            <span class="c1"># pairwise comparisons</span>
            <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">float32</span><span class="p">,</span> <span class="n">float64</span><span class="p">)</span> <span class="ow">or</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">"Conditioning on non-pairwise comparison observations."</span>
                <span class="p">)</span>

            <span class="c1"># Reshaping datapoints and comparisons by batches</span>
            <span class="n">Y_new_batch_shape</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">new_datapoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                <span class="n">Y_new_batch_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="p">)</span>
            <span class="n">new_comparisons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                <span class="n">Y_new_batch_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="p">)</span>
            <span class="c1"># Reshape X since Y may have additional batch dim. from fantasy models</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">Y_new_batch_shape</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

            <span class="n">new_datapoints</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">new_datapoints</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">new_datapoints</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">shifted_comp</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">new_comparisons</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="n">new_comparisons</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">new_comparisons</span><span class="p">,</span> <span class="n">shifted_comp</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># TODO: be smart about how we can update covar matrix here</span>
            <span class="n">new_model</span><span class="o">.</span><span class="n">set_train_data</span><span class="p">(</span><span class="n">new_datapoints</span><span class="p">,</span> <span class="n">new_comparisons</span><span class="p">,</span> <span class="n">update_model</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_model</span></div></div>


<div class="viewcode-block" id="PairwiseLaplaceMarginalLogLikelihood"><a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseLaplaceMarginalLogLikelihood">[docs]</a><span class="k">class</span> <span class="nc">PairwiseLaplaceMarginalLogLikelihood</span><span class="p">(</span><span class="n">MarginalLogLikelihood</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Laplace-approximated marginal log likelihood/evidence for PairwiseGP</span>

<span class="sd">    See (12) from [Chu2005preference]_.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likelihood</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">GP</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Args:</span>
<span class="sd">            likelihood: Used as in args to GPyTorch MarginalLogLikelihood</span>
<span class="sd">            model: Used as in args to GPyTorch MarginalLogLikelihood</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">likelihood</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

<div class="viewcode-block" id="PairwiseLaplaceMarginalLogLikelihood.forward"><a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseLaplaceMarginalLogLikelihood.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post</span><span class="p">:</span> <span class="n">Posterior</span><span class="p">,</span> <span class="n">comp</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">"""Calculate approximated log evidence, i.e., log(P(D|theta))</span>

<span class="sd">        Args:</span>
<span class="sd">            post: training posterior distribution from self.model</span>
<span class="sd">            comp: Comparisons pairs, see PairwiseGP.__init__ for more details</span>

<span class="sd">        Returns:</span>
<span class="sd">            The approximated evidence, i.e., the marginal log likelihood</span>
<span class="sd">        """</span>

        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">likelihood</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">comparisons</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Must train on training data"</span><span class="p">)</span>

        <span class="n">f_map</span> <span class="o">=</span> <span class="n">post</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">likelihood</span><span class="o">.</span><span class="n">log_p</span><span class="p">(</span><span class="n">utility</span><span class="o">=</span><span class="n">f_map</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
        <span class="n">neg_log_likelihood_sum</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">log_likelihood</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># 1/2 f_map^T @ covar_inv @ f_map</span>
        <span class="n">inv_prod</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">f_map</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">model</span><span class="o">.</span><span class="n">covar_chol</span><span class="p">)</span>
        <span class="n">log_prior</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">f_map</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="n">inv_prod</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">log_posterior</span> <span class="o">=</span> <span class="n">neg_log_likelihood_sum</span> <span class="o">+</span> <span class="n">log_prior</span>
        <span class="c1"># log_posterior is the S loss function in [Chu2005preference]_</span>
        <span class="n">log_posterior</span> <span class="o">=</span> <span class="o">-</span><span class="n">log_posterior</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">mll</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">covar</span> <span class="o">@</span> <span class="n">model</span><span class="o">.</span><span class="n">likelihood_hess</span>
        <span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mll</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">mll</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mll</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">mll</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">logdet</span><span class="p">(</span><span class="n">mll</span><span class="p">)</span>

        <span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span> <span class="o">+</span> <span class="n">log_posterior</span>

        <span class="c1"># Sum up mll first so that when adding parameter prior probs it won't</span>
        <span class="c1"># propagate and double count</span>
        <span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Add log probs of priors on the (functions of) parameters</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">closure</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_priors</span><span class="p">():</span>
            <span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prior</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">closure</span><span class="p">(</span><span class="n">module</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">mll</span></div></div>
</pre></div>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">BoTorch</a></h1>
<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../acquisition.html">botorch.acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">botorch.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generation.html">botorch.generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../posteriors.html">botorch.posteriors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optim.html">botorch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fit.html">botorch.fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sampling.html">botorch.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cross_validation.html">botorch.cross_validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../settings.html">botorch.settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../logging.html">botorch.logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test_functions.html">botorch.test_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exceptions.html">botorch.exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">botorch.utils</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="../../../index.html">Documentation overview</a><ul>
<li><a href="../../index.html">Module code</a><ul>
</ul></li>
</ul></li>
</ul>
</div>
<div id="searchbox" role="search" style="display: none">
<h3 id="searchlabel">Quick search</h3>
<div class="searchformwrapper">
<form action="../../../search.html" class="search" method="get">
<input aria-labelledby="searchlabel" autocapitalize="off" autocomplete="off" autocorrect="off" name="q" spellcheck="false" type="text"/>
<input type="submit" value="Go"/>
</form>
</div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
</div>
</div>
<div class="clearer"></div>
</div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/botorch.png" alt="BoTorch" width="66" height="58"/></a><div class="footerSection"><h5>Docs</h5><a href="/docs/introduction">Introduction</a><a href="/docs/getting_started">Getting Started</a><a href="/tutorials/">Tutorials</a><a href="/api/">API Reference</a><a href="https://arxiv.org/abs/1910.06403">Paper</a></div><div class="footerSection"><h5>Legal</h5><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noreferrer noopener">Privacy</a><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noreferrer noopener">Terms</a></div><div class="footerSection"><h5>Social</h5><div class="social"><a class="github-button" href="https://github.com/pytorch/botorch" data-count-href="https://github.com/pytorch/botorch/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star BoTorch on GitHub">botorch</a></div></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Meta Open Source" width="300" height="25"/></a><section class="copyright"> Copyright © 2022 Meta Platforms, Inc</section><script>
            (function() {
              var BAD_BASE = '/botorch/';
              if (window.location.origin !== 'https://botorch.org') {
                var pathname = window.location.pathname;
                var newPathname = pathname.slice(pathname.indexOf(BAD_BASE) === 0 ? BAD_BASE.length : 1);
                var newLocation = 'https://botorch.org/' + newPathname;
                console.log('redirecting to ' + newLocation);
                window.location.href = newLocation;
              }
            })();
          </script></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '207c27d819f967749142d8611de7cb19',
                indexName: 'botorch',
                inputSelector: '#search_input_react'
              });
            </script></body></html>