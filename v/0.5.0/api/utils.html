<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>BoTorch · Bayesian Optimization in PyTorch</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Bayesian Optimization in PyTorch"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="BoTorch · Bayesian Optimization in PyTorch"/><meta property="og:type" content="website"/><meta property="og:url" content="https://botorch.org/v/0.5.0/"/><meta property="og:description" content="Bayesian Optimization in PyTorch"/><meta property="og:image" content="https://botorch.org/v/0.5.0/img/botorch.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://botorch.org/v/0.5.0/img/botorch.png"/><link rel="shortcut icon" href="/v/0.5.0/img/botorch.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-139570076-2', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/v/0.5.0/css/code_block_buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/v/0.5.0/js/code_block_buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/v/0.5.0/js/mathjax.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/v/0.5.0/js/scrollSpy.js"></script><link rel="stylesheet" href="/v/0.5.0/css/main.css"/><script src="/v/0.5.0/js/codetabs.js"></script></head><body><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/v/0.5.0/"><img class="logo" src="/v/0.5.0/img/botorch_logo_lockup_white.png" alt="BoTorch"/><h2 class="headerTitleWithLogo">BoTorch</h2></a><a href="/v/0.5.0/versions"><h3>0.5.0</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/v/0.5.0/docs/introduction" target="_self">Docs</a></li><li class=""><a href="/v/0.5.0/tutorials/" target="_self">Tutorials</a></li><li class=""><a href="/v/0.5.0/api/" target="_self">API Reference</a></li><li class=""><a href="/v/0.5.0/docs/papers" target="_self">Papers</a></li><li class=""><a href="https://github.com/pytorch/botorch" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div>
<script type="text/javascript" id="documentation_options" data-url_root="./" src="/js/documentation_options.js"></script>
<script type="text/javascript" src="/js/jquery.js"></script>
<script type="text/javascript" src="/js/underscore.js"></script>
<script type="text/javascript" src="/js/doctools.js"></script>
<script type="text/javascript" src="/js/language_data.js"></script>
<script type="text/javascript" src="/js/searchtools.js"></script>
<div class="sphinx"><div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body" role="main">
<section id="module-botorch.utils">
<span id="botorch-utils"></span><h1>botorch.utils<a class="headerlink" href="#module-botorch.utils" title="Permalink to this headline">¶</a></h1>
<section id="module-botorch.utils.constraints">
<span id="constraints"></span><h2>Constraints<a class="headerlink" href="#module-botorch.utils.constraints" title="Permalink to this headline">¶</a></h2>
<p>Helpers for handling outcome constraints.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.constraints.get_outcome_constraint_transforms">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.constraints.</span></span><span class="sig-name descname"><span class="pre">get_outcome_constraint_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outcome_constraints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#get_outcome_constraint_transforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.get_outcome_constraint_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Create outcome constraint callables from outcome constraint tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>outcome_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>torch.Tensor</em><em>, </em><em>torch.Tensor</em><em>]</em><em>]</em>) – A tuple of <cite>(A, b)</cite>. For <cite>k</cite> outcome constraints
and <cite>m</cite> outputs at <cite>f(x)`</cite>, <cite>A</cite> is <cite>k x m</cite> and <cite>b</cite> is <cite>k x 1</cite> such
that <cite>A f(x) &lt;= b</cite>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of callables, each mapping a Tensor of size <cite>b x q x m</cite> to a
tensor of size <cite>b x q</cite>, where <cite>m</cite> is the number of outputs of the model.
Negative values imply feasibility. The callables support broadcasting
(e.g. for calling on a tensor of shape <cite>mc_samples x b x q x m</cite>).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Optional[List[Callable[[torch.Tensor], torch.Tensor]]]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># constrain `f(x)[0] &lt;= 0`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outcome_constraints</span> <span class="o">=</span> <span class="n">get_outcome_constraint_transforms</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>
</section>
<section id="module-botorch.utils.containers">
<span id="containers"></span><h2>Containers<a class="headerlink" href="#module-botorch.utils.containers" title="Permalink to this headline">¶</a></h2>
<p>Containers to standardize inputs into models and acquisition functions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.containers.TrainingData">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.containers.</span></span><span class="sig-name descname"><span class="pre">TrainingData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Yvars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/containers.html#TrainingData"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.containers.TrainingData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Standardized container of model training data for models.</p>
<dl class="simple">
<dt>Properties:</dt><dd><dl class="simple">
<dt>Xs: A list of tensors, each of shape <cite>batch_shape x n_i x d</cite>,</dt><dd><p>where <cite>n_i</cite> is the number of training inputs for the i-th model.</p>
</dd>
<dt>Ys: A list of tensors, each of shape <cite>batch_shape x n_i x 1</cite>,</dt><dd><p>where <cite>n_i</cite> is the number of training observations for the i-th
(single-output) model.</p>
</dd>
<dt>Yvars: A list of tensors, each of shape <cite>batch_shape x n_i x 1</cite>,</dt><dd><p>where <cite>n_i</cite> is the number of training observations of the
observation noise for the i-th  (single-output) model.
If <cite>None</cite>, the observation noise level is unobserved.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xs</strong> (<em>List</em><em>[</em><em>torch.Tensor</em><em>]</em>) – </p></li>
<li><p><strong>Ys</strong> (<em>List</em><em>[</em><em>torch.Tensor</em><em>]</em>) – </p></li>
<li><p><strong>Yvars</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>torch.Tensor</em><em>]</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.TrainingData.Xs">
<span class="sig-name descname"><span class="pre">Xs</span></span><em class="property"><span class="pre">:</span> <span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.containers.TrainingData.Xs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.TrainingData.Ys">
<span class="sig-name descname"><span class="pre">Ys</span></span><em class="property"><span class="pre">:</span> <span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.containers.TrainingData.Ys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.TrainingData.Yvars">
<span class="sig-name descname"><span class="pre">Yvars</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><em class="property"> <span class="pre">=</span> <span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.containers.TrainingData.Yvars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.containers.TrainingData.from_block_design">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_block_design</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Yvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/containers.html#TrainingData.from_block_design"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.containers.TrainingData.from_block_design" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a TrainingData object from a block design description.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch.Tensor</em>) – A <cite>batch_shape x n x d</cite> tensor of training points (shared across
all outcomes).</p></li>
<li><p><strong>Y</strong> (<em>torch.Tensor</em>) – A <cite>batch_shape x n x m</cite> tensor of training observations.</p></li>
<li><p><strong>Yvar</strong> (<em>Optional</em><em>[</em><em>torch.Tensor</em><em>]</em>) – A <cite>batch_shape x n x m</cite> tensor of training noise variance
observations, or <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The <cite>TrainingData</cite> object (with <cite>is_block_design=True</cite>).</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.TrainingData.is_block_design">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">is_block_design</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.containers.TrainingData.is_block_design" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates whether training data is a “block design”.</p>
<p>Block designs are designs in which all outcomes are observed
at the same training inputs.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.TrainingData.X">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">X</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Tensor</span></em><a class="headerlink" href="#botorch.utils.containers.TrainingData.X" title="Permalink to this definition">¶</a></dt>
<dd><p>The training inputs (block-design only).</p>
<p>This raises an <cite>UnsupportedError</cite> in the non-block-design case.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.TrainingData.Y">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Tensor</span></em><a class="headerlink" href="#botorch.utils.containers.TrainingData.Y" title="Permalink to this definition">¶</a></dt>
<dd><p>The training observations (block-design only).</p>
<p>This raises an <cite>UnsupportedError</cite> in the non-block-design case.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.TrainingData.Yvar">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">Yvar</span></span><em class="property"><span class="pre">:</span> <span class="pre">Optional[List[torch.Tensor]]</span></em><a class="headerlink" href="#botorch.utils.containers.TrainingData.Yvar" title="Permalink to this definition">¶</a></dt>
<dd><p>The training observations’s noise variance (block-design only).</p>
<p>This raises an <cite>UnsupportedError</cite> in the non-block-design case.</p>
</dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.objective">
<span id="objective"></span><h2>Objective<a class="headerlink" href="#module-botorch.utils.objective" title="Permalink to this headline">¶</a></h2>
<p>Helpers for handling objectives.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.get_objective_weights_transform">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">get_objective_weights_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#get_objective_weights_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.get_objective_weights_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a linear objective callable from a set of weights.</p>
<p>Create a callable mapping a Tensor of size <cite>b x q x m</cite> and an (optional)
Tensor of size <cite>b x q x d</cite> to a Tensor of size <cite>b x q</cite>, where <cite>m</cite> is the
number of outputs of the model using scalarization via the objective weights.
This callable supports broadcasting (e.g. for calling on a tensor of shape
<cite>mc_samples x b x q x m</cite>). For <cite>m = 1</cite>, the objective weight is used to
determine the optimization direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>Optional</em><em>[</em><em>torch.Tensor</em><em>]</em>) – a 1-dimensional Tensor containing a weight for each task.
If not provided, the identity mapping is used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Transform function using the objective weights.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Callable[[torch.Tensor, Optional[torch.Tensor]], torch.Tensor]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span> <span class="o">=</span> <span class="n">get_objective_weights_transform</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.apply_constraints_nonnegative_soft">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">apply_constraints_nonnegative_soft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#apply_constraints_nonnegative_soft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.apply_constraints_nonnegative_soft" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies constraints to a non-negative objective.</p>
<p>This function uses a sigmoid approximation to an indicator function for
each constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>torch.Tensor</em>) – A <cite>n_samples x b x q</cite> Tensor of objective values.</p></li>
<li><p><strong>constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>torch.Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of size <cite>b x q x m</cite>
to a Tensor of size <cite>b x q</cite>, where negative values imply feasibility.
This callable must support broadcasting. Only relevant for multi-
output models (<cite>m</cite> &gt; 1).</p></li>
<li><p><strong>samples</strong> (<em>torch.Tensor</em>) – A <cite>b x q x m</cite> Tensor of samples drawn from the posterior.</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – The temperature parameter for the sigmoid function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>n_samples x b x q</cite>-dim tensor of feasibility-weighted objectives.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.soft_eval_constraint">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">soft_eval_constraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#soft_eval_constraint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.soft_eval_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise evaluation of a constraint in a ‘soft’ fashion</p>
<p><cite>value(x) = 1 / (1 + exp(x / eta))</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lhs</strong> (<em>torch.Tensor</em>) – The left hand side of the constraint <cite>lhs &lt;= 0</cite>.</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – The temperature parameter of the softmax function. As eta
grows larger, this approximates the Heaviside step function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Element-wise ‘soft’ feasibility indicator of the same shape as <cite>lhs</cite>.
For each element <cite>x</cite>, <cite>value(x) -&gt; 0</cite> as <cite>x</cite> becomes positive, and
<cite>value(x) -&gt; 1</cite> as x becomes negative.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.apply_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">apply_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infeasible_cost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#apply_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.apply_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply constraints using an infeasible_cost <cite>M</cite> for negative objectives.</p>
<p>This allows feasibility-weighting an objective for the case where the
objective can be negative by usingthe following strategy:
(1) add <cite>M</cite> to make obj nonnegative
(2) apply constraints using the sigmoid approximation
(3) shift by <cite>-M</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>torch.Tensor</em>) – A <cite>n_samples x b x q</cite> Tensor of objective values.</p></li>
<li><p><strong>constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>torch.Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of size <cite>b x q x m</cite>
to a Tensor of size <cite>b x q</cite>, where negative values imply feasibility.
This callable must support broadcasting. Only relevant for multi-
output models (<cite>m</cite> &gt; 1).</p></li>
<li><p><strong>samples</strong> (<em>torch.Tensor</em>) – A <cite>b x q x m</cite> Tensor of samples drawn from the posterior.</p></li>
<li><p><strong>infeasible_cost</strong> (<em>float</em>) – The infeasible value.</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – The temperature parameter of the sigmoid function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>n_samples x b x q</cite>-dim tensor of feasibility-weighted objectives.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.rounding">
<span id="rounding"></span><h2>Rounding<a class="headerlink" href="#module-botorch.utils.rounding" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.rounding.approximate_round">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.rounding.</span></span><span class="sig-name descname"><span class="pre">approximate_round</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#approximate_round"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.approximate_round" title="Permalink to this definition">¶</a></dt>
<dd><p>Diffentiable approximate rounding function.</p>
<p>This method is a piecewise approximation of a rounding function where
each piece is a hyperbolic tangent function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch.Tensor</em>) – The tensor to round to the nearest integer (element-wise).</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – A temperature hyperparameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The approximately rounded input tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.sampling">
<span id="sampling"></span><h2>Sampling<a class="headerlink" href="#module-botorch.utils.sampling" title="Permalink to this headline">¶</a></h2>
<p>Utilities for MC and qMC sampling.</p>
<p>References</p>
<dl class="citation">
<dt class="label" id="trikalinos2014polytope"><span class="brackets"><a class="fn-backref" href="#id1">Trikalinos2014polytope</a></span></dt>
<dd><p>T. A. Trikalinos and G. van Valkenhoef. Efficient sampling from uniform
density n-polytopes. Technical report, Brown University, 2014.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.manual_seed">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">manual_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#manual_seed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.manual_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Contextmanager for manual setting the torch.random seed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The seed to set the random number generator to.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Generator</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Generator[None, None, None]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">manual_seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.construct_base_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">construct_base_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#construct_base_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.construct_base_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct base samples from a multi-variate standard normal N(0, I_qo).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_shape</strong> (<em>torch.Size</em>) – The batch shape of the base samples to generate. Typically,
this is used with each dimension of size 1, so as to eliminate
sampling variance across batches.</p></li>
<li><p><strong>output_shape</strong> (<em>torch.Size</em>) – The output shape (<cite>q x m</cite>) of the base samples to generate.</p></li>
<li><p><strong>sample_shape</strong> (<em>torch.Size</em>) – The sample shape of the samples to draw.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – If True, use quasi-MC sampling (instead of iid draws).</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – If provided, use as a seed for the RNG.</p></li>
<li><p><strong>device</strong> (<em>Optional</em><em>[</em><em>torch.device</em><em>]</em>) – </p></li>
<li><p><strong>dtype</strong> (<em>Optional</em><em>[</em><em>torch.dtype</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>sample_shape x batch_shape x mutput_shape</cite> dimensional tensor of base
samples, drawn from a N(0, I_qm) distribution (using QMC if <cite>qmc=True</cite>).
Here <cite>output_shape = q x m</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">batch_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">construct_base_samples</span><span class="p">(</span><span class="n">batch_shape</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">,</span> <span class="n">sample_shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.construct_base_samples_from_posterior">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">construct_base_samples_from_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collapse_batch_dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#construct_base_samples_from_posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.construct_base_samples_from_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a tensor of normally distributed base samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>posterior</strong> (<a class="reference internal" href="posteriors.html#botorch.posteriors.posterior.Posterior" title="botorch.posteriors.posterior.Posterior"><em>botorch.posteriors.posterior.Posterior</em></a>) – A Posterior object.</p></li>
<li><p><strong>sample_shape</strong> (<em>torch.Size</em>) – The sample shape of the samples to draw.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – If True, use quasi-MC sampling (instead of iid draws).</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – If provided, use as a seed for the RNG.</p></li>
<li><p><strong>collapse_batch_dims</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>num_samples x 1 x q x m</cite> dimensional Tensor of base samples, drawn
from a N(0, I_qm) distribution (using QMC if <cite>qmc=True</cite>). Here <cite>q</cite> and
<cite>m</cite> are the same as in the posterior’s <cite>event_shape</cite> <cite>b x q x m</cite>.
Importantly, this only obtain a single t-batch of samples, so as to not
introduce any sampling variance across t-batches.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_shape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">construct_base_samples_from_posterior</span><span class="p">(</span><span class="n">posterior</span><span class="p">,</span> <span class="n">sample_shape</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.draw_sobol_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">draw_sobol_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#draw_sobol_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.draw_sobol_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw qMC samples from the box defined by bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite> dimensional tensor specifying box constraints on a
<cite>d</cite>-dimensional space, where bounds[0, :] and bounds[1, :] correspond
to lower and upper bounds, respectively.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of (q-batch) samples. As a best practice, use powers of 2.</p></li>
<li><p><strong>q</strong> (<em>int</em>) – The size of each q-batch.</p></li>
<li><p><strong>batch_shape</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><em>int</em><em>]</em><em>, </em><em>torch.Size</em><em>]</em>) – The batch shape of the samples. If given, returns samples
of shape <cite>n x batch_shape x q x d</cite>, where each batch is an
<cite>n x q x d</cite>-dim tensor of qMC samples.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The seed used for initializing Owen scrambling. If None (default),
use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>n x batch_shape x q x d</cite>-dim tensor of qMC samples from the box
defined by bounds.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">draw_sobol_samples</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.draw_sobol_normal_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">draw_sobol_normal_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#draw_sobol_normal_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.draw_sobol_normal_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw qMC samples from a multi-variate standard normal N(0, I_d)</p>
<p>A primary use-case for this functionality is to compute an QMC average
of f(X) over X where each element of X is drawn N(0, 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the normal distribution.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of samples to return. As a best practice, use powers of 2.</p></li>
<li><p><strong>device</strong> (<em>Optional</em><em>[</em><em>torch.device</em><em>]</em>) – The torch device.</p></li>
<li><p><strong>dtype</strong> (<em>Optional</em><em>[</em><em>torch.dtype</em><em>]</em>) – The torch dtype.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The seed used for initializing Owen scrambling. If None (default),
use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A tensor of qMC standard normal samples with dimension <cite>n x d</cite> with device
and dtype specified by the input.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">draw_sobol_normal_samples</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_hypersphere">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_hypersphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_hypersphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_hypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample uniformly from a unit d-sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the hypersphere.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of samples to return.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – If True, use QMC Sobol sampling (instead of i.i.d. uniform).</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – If provided, use as a seed for the RNG.</p></li>
<li><p><strong>device</strong> (<em>Optional</em><em>[</em><em>torch.device</em><em>]</em>) – The torch device.</p></li>
<li><p><strong>dtype</strong> (<em>Optional</em><em>[</em><em>torch.dtype</em><em>]</em>) – The torch dtype.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An  <cite>n x d</cite> tensor of uniform samples from from the d-hypersphere.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_hypersphere</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_simplex">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_simplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_simplex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_simplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample uniformly from a d-simplex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the simplex.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of samples to return.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – If True, use QMC Sobol sampling (instead of i.i.d. uniform).</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – If provided, use as a seed for the RNG.</p></li>
<li><p><strong>device</strong> (<em>Optional</em><em>[</em><em>torch.device</em><em>]</em>) – The torch device.</p></li>
<li><p><strong>dtype</strong> (<em>Optional</em><em>[</em><em>torch.dtype</em><em>]</em>) – The torch dtype.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <cite>n x d</cite> tensor of uniform samples from from the d-simplex.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_simplex</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_polytope">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_polytope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Hit and run sampler from uniform sampling points from a polytope,
described via inequality constraints A*x&lt;=b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>torch.Tensor</em>) – A Tensor describing inequality constraints
so that all samples satisfy Ax&lt;=b.</p></li>
<li><p><strong>b</strong> (<em>torch.Tensor</em>) – A Tensor describing the inequality constraints
so that all samples satisfy Ax&lt;=b.</p></li>
<li><p><strong>x0</strong> (<em>torch.Tensor</em>) – A <cite>d</cite>-dim Tensor representing a starting point of the chain
satisfying the constraints.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of resulting samples kept in the output.</p></li>
<li><p><strong>n0</strong> (<em>int</em>) – The number of burn-in samples. The chain will produce
n+n0 samples but the first n0 samples are not saved.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The seed for the sampler. If omitted, use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(n, d) dim Tensor containing the resulting samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.batched_multinomial">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">batched_multinomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#batched_multinomial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.batched_multinomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from multinomial with an arbitrary number of batch dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>torch.Tensor</em>) – A <cite>batch_shape x num_categories</cite> tensor of weights. For each batch
index <cite>i, j, …</cite>, this functions samples from a multinomial with <cite>input</cite>
<cite>weights[i, j, …, :]</cite>. Note that the weights need not sum to one, but must
be non-negative, finite and have a non-zero sum.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to draw for each batch index. Must be smaller
than <cite>num_categories</cite> if <cite>replacement=False</cite>.</p></li>
<li><p><strong>replacement</strong> (<em>bool</em>) – If True, samples are drawn with replacement.</p></li>
<li><p><strong>generator</strong> (<em>Optional</em><em>[</em><em>torch._C.Generator</em><em>]</em>) – A a pseudorandom number generator for sampling.</p></li>
<li><p><strong>out</strong> (<em>Optional</em><em>[</em><em>torch.Tensor</em><em>]</em>) – The output tensor (optional). If provided, must be of size
<cite>batch_shape x num_samples</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>batch_shape x num_samples</cite> tensor of samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.LongTensor</p>
</dd>
</dl>
<p>This is a thin wrapper around <cite>torch.multinomial</cite> that allows weight (<cite>input</cite>)
tensors with an arbitrary number of batch dimensions (<cite>torch.multinomial</cite> only
allows a single batch dimension). The calling signature is the same as for
<cite>torch.multinomial</cite>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">batched_multinomial</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># shape is 2 x 3 x 4</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.find_interior_point">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">find_interior_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A_eq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_eq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#find_interior_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.find_interior_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an interior point of a polytope via linear programming.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>numpy.ndarray</em>) – A <cite>n_ineq x d</cite>-dim numpy array containing the coefficients of the
constraint inequalities.</p></li>
<li><p><strong>b</strong> (<em>numpy.ndarray</em>) – A <cite>n_ineq x 1</cite>-dim numpy array containing the right hand sides of
the constraint inequalities.</p></li>
<li><p><strong>A_eq</strong> (<em>Optional</em><em>[</em><em>numpy.ndarray</em><em>]</em>) – A <cite>n_eq x d</cite>-dim numpy array containing the coefficients of the
constraint equalities.</p></li>
<li><p><strong>b_eq</strong> (<em>Optional</em><em>[</em><em>numpy.ndarray</em><em>]</em>) – A <cite>n_eq x 1</cite>-dim numpy array containing the right hand sides of
the constraint equalities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>d</cite>-dim numpy array containing an interior point of the polytope.
This function will raise a ValueError if there is no such point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
<dl class="simple">
<dt>This method solves the following Linear Program:</dt><dd><p>min -s subject to A @ x &lt;= b - 2 * s, s &gt;= 0, A_eq @ x = b_eq</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.sampling.PolytopeSampler">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">PolytopeSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#PolytopeSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.PolytopeSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Base class for samplers that sample points from a polytope.</p>
<p>Initialize PolytopeSampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(A, b)</cite> describing inequality
constraints <cite>A @ x &lt;= b</cite>, where <cite>A</cite> is a <cite>n_ineq_con x d</cite>-dim
Tensor and <cite>b</cite> is a <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite>
the number of inequalities and <cite>d</cite> the dimension of the sample space.</p></li>
<li><p><strong>equality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(C, d)</cite> describing the equality constraints
<cite>C @ x = d</cite>, where <cite>C</cite> is a <cite>n_eq_con x d</cite>-dim Tensor and <cite>d</cite> is a
<cite>n_eq_con x 1</cite>-dim Tensor with <cite>n_eq_con</cite> the number of equalities.</p></li>
<li><p><strong>interior_point</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>d_sample x 1</cite>-dim Tensor presenting a point in the
(relative) interior of the polytope. If omitted, determined
automatically by solving a Linear Program.</p></li>
<li><p><strong>bounds</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>2 x d</cite>-dim tensor of box bounds.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.PolytopeSampler.feasible">
<span class="sig-name descname"><span class="pre">feasible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#PolytopeSampler.feasible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.PolytopeSampler.feasible" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a point is contained in the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>torch.Tensor</em>) – A <cite>d x 1</cite>-dim Tensor.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if <cite>x</cite> is contained inside the polytope (incl. its boundary),
False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.PolytopeSampler.find_interior_point">
<span class="sig-name descname"><span class="pre">find_interior_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#PolytopeSampler.find_interior_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.PolytopeSampler.find_interior_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an interior point of the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>d x 1</cite>-dim Tensor representing a point contained in the polytope.
This function will raise a ValueError if there is no such point.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.PolytopeSampler.draw">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#PolytopeSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.PolytopeSampler.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw samples from the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of samples.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>n x d_sample</cite> Tensor of samples from the polytope.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.sampling.HitAndRunPolytopeSampler">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">HitAndRunPolytopeSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#HitAndRunPolytopeSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.HitAndRunPolytopeSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.sampling.PolytopeSampler" title="botorch.utils.sampling.PolytopeSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.utils.sampling.PolytopeSampler</span></code></a></p>
<p>A sampler for sampling from a polyope using a hit-and-run algorithm.</p>
<p>A sampler for sampling from a polyope using a hit-and-run algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(A, b)</cite> describing inequality
constraints <cite>A @ x &lt;= b</cite>, where <cite>A</cite> is a <cite>n_ineq_con x d</cite>-dim
Tensor and <cite>b</cite> is a <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite>
the number of inequalities and <cite>d</cite> the dimension of the sample space.</p></li>
<li><p><strong>equality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(C, d)</cite> describing the equality constraints
<cite>C @ x = d</cite>, where <cite>C</cite> is a <cite>n_eq_con x d</cite>-dim Tensor and <cite>d</cite> is a
<cite>n_eq_con x 1</cite>-dim Tensor with <cite>n_eq_con</cite> the number of equalities.</p></li>
<li><p><strong>interior_point</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>d_sample x 1</cite>-dim Tensor presenting a point in the
(relative) interior of the polytope. If omitted, determined
automatically by solving a Linear Program.</p></li>
<li><p><strong>bounds</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>2 x d</cite>-dim tensor of box bounds.</p></li>
<li><p><strong>n_burnin</strong> (<em>int</em>) – The number of burn in samples.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.HitAndRunPolytopeSampler.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#HitAndRunPolytopeSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.HitAndRunPolytopeSampler.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw samples from the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of samples.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>n x d_sample</cite> Tensor of samples from the polytope.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.sampling.DelaunayPolytopeSampler">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">DelaunayPolytopeSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#DelaunayPolytopeSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.DelaunayPolytopeSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.sampling.PolytopeSampler" title="botorch.utils.sampling.PolytopeSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.utils.sampling.PolytopeSampler</span></code></a></p>
<p>A polytope sampler using Delaunay triangulation.</p>
<p>This sampler first enumerates the vertices of the constraint polytope and
then uses a Delaunay triangulation to tesselate its convex hull.</p>
<p>The sampling happens in two stages:
1. First, we sample from the set of hypertriangles generated by the
Delaunay triangulation (i.e. which hyper-triangle to draw the sample
from) with probabilities proportional to the triangle volumes.
2. Then, we sample uniformly from the chosen hypertriangle by sampling
uniformly from the unit simplex of the appropriate dimension, and
then computing the convex combination of the vertices of the
hypertriangle according to that draw from the simplex.</p>
<p>The best reference (not exactly the same, but functionally equivalent) is
<a class="reference internal" href="#trikalinos2014polytope" id="id1"><span>[Trikalinos2014polytope]</span></a>. A simple R implementation is available at
<a class="reference external" href="https://github.com/gertvv/tesselample">https://github.com/gertvv/tesselample</a>.</p>
<p>Initialize DelaunayPolytopeSampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(A, b)</cite> describing inequality
constraints <cite>A @ x &lt;= b</cite>, where <cite>A</cite> is a <cite>n_ineq_con x d</cite>-dim
Tensor and <cite>b</cite> is a <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite>
the number of inequalities and <cite>d</cite> the dimension of the sample space.</p></li>
<li><p><strong>equality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(C, d)</cite> describing the equality constraints
<cite>C @ x = d</cite>, where <cite>C</cite> is a <cite>n_eq_con x d</cite>-dim Tensor and <cite>d</cite> is a
<cite>n_eq_con x 1</cite>-dim Tensor with <cite>n_eq_con</cite> the number of equalities.</p></li>
<li><p><strong>interior_point</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>d_sample x 1</cite>-dim Tensor presenting a point in the
(relative) interior of the polytope. If omitted, determined
automatically by solving a Linear Program.</p></li>
<li><p><strong>bounds</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>2 x d</cite>-dim tensor of box bounds.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p>Warning: The vertex enumeration performed in this algorithm can become
extremely costly if there are a large number of inequalities. Similarly,
the triangulation can get very expensive in high dimensions. Only use
this algorithm for moderate dimensions / moderately complex constraint sets.
An alternative is the <cite>HitAndRunPolytopeSampler</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.DelaunayPolytopeSampler.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#DelaunayPolytopeSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.DelaunayPolytopeSampler.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw samples from the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of samples.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>n x d_sample</cite> Tensor of samples from the polytope.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.get_polytope_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">get_polytope_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thinning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#get_polytope_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.get_polytope_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from polytope defined by box bounds and (in)equality constraints.</p>
<p>This uses a hit-and-run Markov chain sampler.</p>
<p>TODO: make this method return the sampler object, to avoid doing burn-in
every time we draw samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of samples.</p></li>
<li><p><strong>bounds</strong> (<em>torch.Tensor</em>) – A <cite>2 x d</cite>-dim tensor containing the box bounds.</p></li>
<li><p><strong>constraints</strong> (<em>equality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>constraints</strong> – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The random seed.</p></li>
<li><p><strong>thinning</strong> (<em>int</em>) – The amount of thinning.</p></li>
<li><p><strong>n_burnin</strong> (<em>int</em>) – The number of burn-in samples for the Markov chain sampler.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Tuple</em><em>[</em><em>torch.Tensor</em><em>, </em><em>torch.Tensor</em><em>, </em><em>float</em><em>]</em><em>]</em><em>]</em>) – </p></li>
<li><p><strong>equality_constraints</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Tuple</em><em>[</em><em>torch.Tensor</em><em>, </em><em>torch.Tensor</em><em>, </em><em>float</em><em>]</em><em>]</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>n x d</cite>-dim tensor of samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sparse_to_dense_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sparse_to_dense_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sparse_to_dense_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sparse_to_dense_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert parameter constraints from a sparse format into a dense format.</p>
<p>This method converts sparse triples of the form (indices, coefficients, rhs)
to constraints of the form Ax &gt;= b or Ax = b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The input dimension.</p></li>
<li><p><strong>constraints</strong> (<em>inequality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an (in)equality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite> or
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A: A <cite>n_constraints x d</cite>-dim tensor of coefficients.</p></li>
<li><p>b: A <cite>n_constraints x 1</cite>-dim tensor of right hand sides.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A two-element tuple containing</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.gp_sampling">
<span id="sampling-from-gp-priors"></span><h2>Sampling from GP priors<a class="headerlink" href="#module-botorch.utils.gp_sampling" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">GPDraw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#GPDraw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>Convenience wrapper for sampling a function from a GP prior.</p>
<p>This wrapper implicitly defines the GP sample as a self-updating function by keeping
track of the evaluated points and respective base samples used during the
evaluation.</p>
<p>This does not yet support multi-output models.</p>
<p>Construct a GP function sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – The Model defining the GP prior.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw.Xs">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">Xs</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Tensor</span></em><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw.Xs" title="Permalink to this definition">¶</a></dt>
<dd><p>A <cite>(batch_shape) x n_eval x d</cite>-dim tensor of locations at which the GP was
evaluated (or <cite>None</cite> if the sample has never been evaluated).</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw.Ys">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">Ys</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Tensor</span></em><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw.Ys" title="Permalink to this definition">¶</a></dt>
<dd><p>A <cite>(batch_shape) x n_eval x d</cite>-dim tensor of associated function values (or
<cite>None</cite> if the sample has never been evaluated).</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#GPDraw.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the GP sample function at a set of points X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>torch.Tensor</em>) – A <cite>batch_shape x n x d</cite>-dim tensor of points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The value of the GP sample at the <cite>n</cite> points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.RandomFourierFeatures">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">RandomFourierFeatures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_rff_features</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#RandomFourierFeatures"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.RandomFourierFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>A class that represents Random Fourier Features.</p>
<p>Initialize RandomFourierFeatures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel</strong> (<em>Kernel</em>) – the GP kernel</p></li>
<li><p><strong>input_dim</strong> (<em>int</em>) – the input dimension to the GP kernel</p></li>
<li><p><strong>num_rff_features</strong> (<em>int</em>) – the number of fourier features</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.RandomFourierFeatures.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#RandomFourierFeatures.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.RandomFourierFeatures.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Get fourier basis features for the provided inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>torch.Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.RandomFourierFeatures.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.gp_sampling.RandomFourierFeatures.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.get_deterministic_model">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">get_deterministic_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#get_deterministic_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.get_deterministic_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a deterministic model using the provided weights and bases for each output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>List</em><em>[</em><em>torch.Tensor</em><em>]</em>) – a list of weights with <cite>m</cite> elements</p></li>
<li><p><strong>bases</strong> (<em>List</em><em>[</em><a class="reference internal" href="#botorch.utils.gp_sampling.RandomFourierFeatures" title="botorch.utils.gp_sampling.RandomFourierFeatures"><em>botorch.utils.gp_sampling.RandomFourierFeatures</em></a><em>]</em>) – a list of RandomFourierFeatures with <cite>m</cite> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A deterministic model.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="models.html#botorch.models.deterministic.GenericDeterministicModel" title="botorch.models.deterministic.GenericDeterministicModel">botorch.models.deterministic.GenericDeterministicModel</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.get_weights_posterior">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">get_weights_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#get_weights_posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.get_weights_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample bayesian linear regression weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch.Tensor</em>) – a <cite>n x num_rff_features</cite>-dim tensor of inputs</p></li>
<li><p><strong>y</strong> (<em>torch.Tensor</em>) – a <cite>n</cite>-dim tensor of outputs</p></li>
<li><p><strong>sigma_sq</strong> (<em>float</em>) – the noise variance</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The posterior distribution over the weights.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.distributions.multivariate_normal.MultivariateNormal</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.get_gp_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">get_gp_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_outputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_rff_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#get_gp_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.get_gp_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample functions from GP posterior using RFF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>botorch.models.model.Model</em></a>) – the model</p></li>
<li><p><strong>num_outputs</strong> (<em>int</em>) – the number of outputs</p></li>
<li><p><strong>n_samples</strong> (<em>int</em>) – the number of sampled functions to draw</p></li>
<li><p><strong>num_rff_features</strong> (<em>int</em>) – the number of random fourier features</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of sampled functions.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="models.html#botorch.models.deterministic.GenericDeterministicModel" title="botorch.models.deterministic.GenericDeterministicModel">botorch.models.deterministic.GenericDeterministicModel</a>]</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.testing">
<span id="testing"></span><h2>Testing<a class="headerlink" href="#module-botorch.utils.testing" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">BotorchTestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BotorchTestCase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.case.TestCase</span></code></p>
<p>Basic test case for Botorch.</p>
<dl class="simple">
<dt>This</dt><dd><ol class="arabic simple">
<li><p>sets the default device to be <cite>torch.device(“cpu”)</cite></p></li>
<li><p>ensures that no warnings are suppressed by default.</p></li>
</ol>
</dd>
</dl>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase.device">
<span class="sig-name descname"><span class="pre">device</span></span><em class="property"> <span class="pre">=</span> <span class="pre">device(type='cpu')</span></em><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase.device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase.setUp">
<span class="sig-name descname"><span class="pre">setUp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BotorchTestCase.setUp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase.setUp" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for setting up the test fixture before exercising it.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.BaseTestProblemBaseTestCase">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">BaseTestProblemBaseTestCase</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#BaseTestProblemBaseTestCase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BaseTestProblemBaseTestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.testing.BaseTestProblemBaseTestCase.functions">
<span class="sig-name descname"><span class="pre">functions</span></span><em class="property"><span class="pre">:</span> <span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="test_functions.html#botorch.test_functions.base.BaseTestProblem" title="botorch.test_functions.base.BaseTestProblem"><span class="pre">botorch.test_functions.base.BaseTestProblem</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.BaseTestProblemBaseTestCase.functions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.BaseTestProblemBaseTestCase.test_forward">
<span class="sig-name descname"><span class="pre">test_forward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BaseTestProblemBaseTestCase.test_forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BaseTestProblemBaseTestCase.test_forward" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionBaseTestCase">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">SyntheticTestFunctionBaseTestCase</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#SyntheticTestFunctionBaseTestCase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionBaseTestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.testing.BaseTestProblemBaseTestCase" title="botorch.utils.testing.BaseTestProblemBaseTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.utils.testing.BaseTestProblemBaseTestCase</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionBaseTestCase.test_optimal_value">
<span class="sig-name descname"><span class="pre">test_optimal_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#SyntheticTestFunctionBaseTestCase.test_optimal_value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionBaseTestCase.test_optimal_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionBaseTestCase.test_optimizer">
<span class="sig-name descname"><span class="pre">test_optimizer</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#SyntheticTestFunctionBaseTestCase.test_optimizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionBaseTestCase.test_optimizer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionBaseTestCase.functions">
<span class="sig-name descname"><span class="pre">functions</span></span><em class="property"><span class="pre">:</span> <span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="test_functions.html#botorch.test_functions.base.BaseTestProblem" title="botorch.test_functions.base.BaseTestProblem"><span class="pre">botorch.test_functions.base.BaseTestProblem</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionBaseTestCase.functions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MockPosterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockPosterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockPosterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="posteriors.html#botorch.posteriors.posterior.Posterior" title="botorch.posteriors.posterior.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.posteriors.posterior.Posterior</span></code></a></p>
<p>Mock object that implements dummy methods and feeds through specified outputs</p>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.device">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.device</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The torch device of the posterior.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.dtype">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.dtype</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The torch dtype of the posterior.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.event_shape">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">event_shape</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Size</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.event_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The event shape (i.e. the shape of a single sample).</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.mean">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">mean</span></span><a class="headerlink" href="#botorch.utils.testing.MockPosterior.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>The mean of the posterior as a <cite>(b) x n x m</cite>-dim Tensor.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.variance">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">variance</span></span><a class="headerlink" href="#botorch.utils.testing.MockPosterior.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>The variance of the posterior as a <cite>(b) x n x m</cite>-dim Tensor.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockPosterior.rsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockPosterior.rsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Mock sample by repeating self._samples. If base_samples is provided,
do a shape check but return the same mock samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_shape</strong> (<em>Optional</em><em>[</em><em>torch.Size</em><em>]</em>) – </p></li>
<li><p><strong>base_samples</strong> (<em>Optional</em><em>[</em><em>torch.Tensor</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MockModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.models.model.Model</span></code></a></p>
<p>Mock object that implements dummy methods and feeds through specified outputs</p>
<p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>posterior</strong> (<a class="reference internal" href="#botorch.utils.testing.MockPosterior" title="botorch.utils.testing.MockPosterior"><em>MockPosterior</em></a>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel.posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel.posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the posterior over model outputs at the provided points.</p>
<dl class="simple">
<dt>Note: The input transforms should be applied here using</dt><dd><p><cite>self.transform_inputs(X)</cite> after the <cite>self.eval()</cite> call and before
any <cite>model.forward</cite> or <cite>model.likelihood</cite> calls.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch.Tensor</em>) – A <cite>b x q x d</cite>-dim Tensor, where <cite>d</cite> is the dimension of the
feature space, <cite>q</cite> is the number of points considered jointly,
and <cite>b</cite> is the batch dimension.</p></li>
<li><p><strong>output_indices</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em>) – A list of indices, corresponding to the outputs over
which to compute the posterior (if the model is multi-output).
Can be used to speed up computation if only a subset of the
model’s outputs are required for optimization. If omitted,
computes the posterior over all model outputs.</p></li>
<li><p><strong>observation_noise</strong> (<em>bool</em>) – If True, add observation noise to the posterior.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>Posterior</cite> object, representing a batch of <cite>b</cite> joint distributions
over <cite>q</cite> points and <cite>m</cite> outputs each.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.testing.MockPosterior" title="botorch.utils.testing.MockPosterior">botorch.utils.testing.MockPosterior</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.num_outputs">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">num_outputs</span></span><em class="property"><span class="pre">:</span> <span class="pre">int</span></em><a class="headerlink" href="#botorch.utils.testing.MockModel.num_outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of outputs of the model.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.batch_shape">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">batch_shape</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Size</span></em><a class="headerlink" href="#botorch.utils.testing.MockModel.batch_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The batch shape of the model.</p>
<p>This is a batch shape from an I/O perspective, independent of the internal
representation of the model (as e.g. in BatchedMultiOutputGPyTorchModel).
For a model with <cite>m</cite> outputs, a <cite>test_batch_shape x q x d</cite>-shaped input <cite>X</cite>
to the <cite>posterior</cite> method returns a Posterior object over an output of
shape <cite>broadcast(test_batch_shape, model.batch_shape) x q x m</cite>.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.state_dict">
<span class="sig-name descname"><span class="pre">state_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel.state_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel.state_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary containing a whole state of the module.</p>
<p>Both parameters and persistent buffers (e.g. running averages) are
included. Keys are corresponding parameter and buffer names.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a dictionary containing a whole state of the module</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">module</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">['bias', 'weight']</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.load_state_dict">
<span class="sig-name descname"><span class="pre">load_state_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel.load_state_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel.load_state_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies parameters and buffers from <a class="reference internal" href="#botorch.utils.testing.MockModel.state_dict" title="botorch.utils.testing.MockModel.state_dict"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code></a> into
this module and its descendants. If <code class="xref py py-attr docutils literal notranslate"><span class="pre">strict</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then
the keys of <a class="reference internal" href="#botorch.utils.testing.MockModel.state_dict" title="botorch.utils.testing.MockModel.state_dict"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code></a> must exactly match the keys returned
by this module’s <code class="xref py py-meth docutils literal notranslate"><span class="pre">state_dict()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_dict</strong> (<em>dict</em>) – a dict containing parameters and
persistent buffers.</p></li>
<li><p><strong>strict</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether to strictly enforce that the keys
in <a class="reference internal" href="#botorch.utils.testing.MockModel.state_dict" title="botorch.utils.testing.MockModel.state_dict"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code></a> match the keys returned by this module’s
<code class="xref py py-meth docutils literal notranslate"><span class="pre">state_dict()</span></code> function. Default: <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>missing_keys</strong> is a list of str containing the missing keys</p></li>
<li><p><strong>unexpected_keys</strong> is a list of str containing the unexpected keys</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> with <code class="docutils literal notranslate"><span class="pre">missing_keys</span></code> and <code class="docutils literal notranslate"><span class="pre">unexpected_keys</span></code> fields</p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.testing.MockModel.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MockAcquisitionFunction">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MockAcquisitionFunction</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockAcquisitionFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockAcquisitionFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mock acquisition function object that implements dummy methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockAcquisitionFunction.set_X_pending">
<span class="sig-name descname"><span class="pre">set_X_pending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_pending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockAcquisitionFunction.set_X_pending"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockAcquisitionFunction.set_X_pending" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X_pending</strong> (<em>Optional</em><em>[</em><em>torch.Tensor</em><em>]</em>) – </p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MultiObjectiveTestProblemBaseTestCase</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemBaseTestCase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.testing.BaseTestProblemBaseTestCase" title="botorch.utils.testing.BaseTestProblemBaseTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.utils.testing.BaseTestProblemBaseTestCase</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase.test_attributes">
<span class="sig-name descname"><span class="pre">test_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemBaseTestCase.test_attributes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase.test_attributes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase.test_max_hv">
<span class="sig-name descname"><span class="pre">test_max_hv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemBaseTestCase.test_max_hv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase.test_max_hv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase.test_ref_point">
<span class="sig-name descname"><span class="pre">test_ref_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemBaseTestCase.test_ref_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase.test_ref_point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase.functions">
<span class="sig-name descname"><span class="pre">functions</span></span><em class="property"><span class="pre">:</span> <span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="test_functions.html#botorch.test_functions.base.BaseTestProblem" title="botorch.test_functions.base.BaseTestProblem"><span class="pre">botorch.test_functions.base.BaseTestProblem</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase.functions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedMultiObjectiveTestProblemBaseTestCase">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">ConstrainedMultiObjectiveTestProblemBaseTestCase</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#ConstrainedMultiObjectiveTestProblemBaseTestCase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.ConstrainedMultiObjectiveTestProblemBaseTestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase" title="botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.utils.testing.MultiObjectiveTestProblemBaseTestCase</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedMultiObjectiveTestProblemBaseTestCase.test_num_constraints">
<span class="sig-name descname"><span class="pre">test_num_constraints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#ConstrainedMultiObjectiveTestProblemBaseTestCase.test_num_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.ConstrainedMultiObjectiveTestProblemBaseTestCase.test_num_constraints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedMultiObjectiveTestProblemBaseTestCase.test_evaluate_slack_true">
<span class="sig-name descname"><span class="pre">test_evaluate_slack_true</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#ConstrainedMultiObjectiveTestProblemBaseTestCase.test_evaluate_slack_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.ConstrainedMultiObjectiveTestProblemBaseTestCase.test_evaluate_slack_true" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedMultiObjectiveTestProblemBaseTestCase.functions">
<span class="sig-name descname"><span class="pre">functions</span></span><em class="property"><span class="pre">:</span> <span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="test_functions.html#botorch.test_functions.base.BaseTestProblem" title="botorch.test_functions.base.BaseTestProblem"><span class="pre">botorch.test_functions.base.BaseTestProblem</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.ConstrainedMultiObjectiveTestProblemBaseTestCase.functions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.torch">
<span id="torch"></span><h2>Torch<a class="headerlink" href="#module-botorch.utils.torch" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.torch.</span></span><span class="sig-name descname"><span class="pre">BufferDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>Holds buffers in a dictionary.</p>
<p>BufferDict can be indexed like a regular Python dictionary, but buffers it
contains are properly registered, and will be visible by all Module methods.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code> is an <strong>ordered</strong> dictionary that respects</p>
<ul class="simple">
<li><p>the order of insertion, and</p></li>
<li><p>in <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>, the order of the merged <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>
or another <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code> (the argument to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>).</p></li>
</ul>
<p>Note that <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> with other unordered mapping
types (e.g., Python’s plain <code class="docutils literal notranslate"><span class="pre">dict</span></code>) does not preserve the order of the
merged mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>buffers</strong> (<em>iterable</em><em>, </em><em>optional</em>) – a mapping (dictionary) of
(string : <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) or an iterable of key-value pairs
of type (string, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>)</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModule</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MyModule</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">({</span>
                <span class="s1">'left'</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                <span class="s1">'right'</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">})</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all items from the BufferDict.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove key from the BufferDict and return its buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> (<em>string</em>) – key to pop from the BufferDict</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable of the BufferDict keys.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.items"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable of the BufferDict key/value pairs.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable of the BufferDict values.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffers</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code> with the key-value pairs from a
mapping or an iterable, overwriting existing keys.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">buffers</span></code> is an <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>, a <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code>,
or an iterable of key-value pairs, the order of new elements in it is
preserved.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>buffers</strong> (<em>iterable</em>) – a mapping (dictionary) from string to
<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, or an iterable of
key-value pairs of type (string, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.extra_repr">
<span class="sig-name descname"><span class="pre">extra_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.extra_repr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.extra_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the extra representation of the module</p>
<p>To print customized extra information, you should re-implement
this method in your own modules. Both single-line and multi-line
strings are acceptable.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.torch.BufferDict.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.transforms">
<span id="transformations"></span><h2>Transformations<a class="headerlink" href="#module-botorch.utils.transforms" title="Permalink to this headline">¶</a></h2>
<p>Some basic data transformation helpers.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.squeeze_last_dim">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">squeeze_last_dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#squeeze_last_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.squeeze_last_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Squeeze the last dimension of a Tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>torch.Tensor</em>) – A <cite>… x d</cite>-dim Tensor.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The input tensor with last dimension squeezed.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y_squeezed</span> <span class="o">=</span> <span class="n">squeeze_last_dim</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.standardize">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">standardize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#standardize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.standardize" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardizes (zero mean, unit variance) a tensor by dim=-2.</p>
<p>If the tensor is single-dimensional, simply standardizes the tensor.
If for some batch index all elements are equal (or if there is only a single
data point), this function will return 0 for that batch index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>torch.Tensor</em>) – A <cite>batch_shape x n x m</cite>-dim tensor.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The standardized <cite>Y</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y_standardized</span> <span class="o">=</span> <span class="n">standardize</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.normalize">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Min-max normalize X w.r.t. the provided bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch.Tensor</em>) – <cite>… x d</cite> tensor of data</p></li>
<li><p><strong>bounds</strong> (<em>torch.Tensor</em>) – <cite>2 x d</cite> tensor of lower and upper bounds for each of the X’s d
columns.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>… x d</cite>-dim tensor of normalized data, given by</dt><dd><p><cite>(X - bounds[0]) / (bounds[1] - bounds[0])</cite>. If all elements of <cite>X</cite>
are contained within <cite>bounds</cite>, the normalized values will be
contained within <cite>[0, 1]^d</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.unnormalize">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">unnormalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#unnormalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.unnormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-normalizes X w.r.t. the provided bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch.Tensor</em>) – <cite>… x d</cite> tensor of data</p></li>
<li><p><strong>bounds</strong> (<em>torch.Tensor</em>) – <cite>2 x d</cite> tensor of lower and upper bounds for each of the X’s d
columns.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>… x d</cite>-dim tensor of unnormalized data, given by</dt><dd><p><cite>X * (bounds[1] - bounds[0]) + bounds[0]</cite>. If all elements of <cite>X</cite>
are contained in <cite>[0, 1]^d</cite>, the un-normalized values will be
contained within <cite>bounds</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">unnormalize</span><span class="p">(</span><span class="n">X_normalized</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.normalize_indices">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">normalize_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#normalize_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.normalize_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize a list of indices to ensure that they are positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em>) – A list of indices (may contain negative indices for indexing
“from the back”).</p></li>
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the tensor to index.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A normalized list of indices such that each index is between <cite>0</cite> and
<cite>d-1</cite>, or None if indices is None.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Optional[List[int]]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.t_batch_mode_transform">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">t_batch_mode_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expected_q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assert_output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#t_batch_mode_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.t_batch_mode_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for decorators taking a t-batched <cite>X</cite> tensor.</p>
<p>This method creates decorators for instance methods to transform an input tensor
<cite>X</cite> to t-batch mode (i.e. with at least 3 dimensions). This assumes the tensor
has a q-batch dimension. The decorator also checks the q-batch size if <cite>expected_q</cite>
is provided, and the output shape if <cite>assert_output_shape</cite> is <cite>True</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expected_q</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The expected q-batch size of X. If specified, this will raise an
AssertionError if X’s q-batch size does not equal expected_q.</p></li>
<li><p><strong>assert_output_shape</strong> (<em>bool</em>) – If <cite>True</cite>, this will raise an AssertionError if the
output shape does not match either the t-batch shape of X,
or the <cite>acqf.model.batch_shape</cite> for acquisition functions using
batched models.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The decorated instance method.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Callable[[Callable[[Any, torch.Tensor], Any]], Callable[[Any, torch.Tensor], Any]]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ExampleClass</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@t_batch_mode_transform</span><span class="p">(</span><span class="n">expected_q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span> <span class="nf">single_q_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="o">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@t_batch_mode_transform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span> <span class="nf">arbitrary_q_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="o">...</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.concatenate_pending_points">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">concatenate_pending_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#concatenate_pending_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.concatenate_pending_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator concatenating X_pending into an acquisition function’s argument.</p>
<p>This decorator works on the <cite>forward</cite> method of acquisition functions taking
a tensor <cite>X</cite> as the argument. If the acquisition function has an <cite>X_pending</cite>
attribute (that is not <cite>None</cite>), this is concatenated into the input <cite>X</cite>,
appropriately expanding the pending points to match the batch shape of <cite>X</cite>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ExampleAcquisitionFunction</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@concatenate_pending_points</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@t_batch_mode_transform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="o">...</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> (<em>Callable</em><em>[</em><em>[</em><em>Any</em><em>, </em><em>torch.Tensor</em><em>]</em><em>, </em><em>Any</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Callable[[Any, torch.Tensor], Any]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.match_batch_shape">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">match_batch_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#match_batch_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.match_batch_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches the batch dimension of a tensor to that of another tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>torch.Tensor</em>) – A <cite>batch_shape_X x q x d</cite> tensor, whose batch dimensions that
correspond to batch dimensions of <cite>Y</cite> are to be matched to those
(if compatible).</p></li>
<li><p><strong>Y</strong> (<em>torch.Tensor</em>) – A <cite>batch_shape_Y x q’ x d</cite> tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>batch_shape_Y x q x d</cite> tensor containing the data of <cite>X</cite> expanded to
the batch dimensions of <cite>Y</cite> (if compatible). For instance, if <cite>X</cite> is
<cite>b’’ x b’ x q x d</cite> and <cite>Y</cite> is <cite>b x q x d</cite>, then the returned tensor is
<cite>b’’ x b x q x d</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_matched</span> <span class="o">=</span> <span class="n">match_batch_shape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_matched</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([2, 6, 5, 3])</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.convert_to_target_pre_hook">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">convert_to_target_pre_hook</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#convert_to_target_pre_hook"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.convert_to_target_pre_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-hook for automatically calling <cite>.to(X)</cite> on module prior to <cite>forward</cite></p>
</dd></dl>
</section>
<section id="module-botorch.utils.feasible_volume">
<span id="feasible-volume"></span><h2>Feasible Volume<a class="headerlink" href="#module-botorch.utils.feasible_volume" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.feasible_volume.get_feasible_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.feasible_volume.</span></span><span class="sig-name descname"><span class="pre">get_feasible_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/feasible_volume.html#get_feasible_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.feasible_volume.get_feasible_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks which of the samples satisfy all of the inequality constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samples</strong> (<em>torch.Tensor</em>) – A <cite>sample size x d</cite> size tensor of feature samples,
where d is a feature dimension.</p></li>
<li><p><strong>constraints</strong> (<em>inequality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Tuple</em><em>[</em><em>torch.Tensor</em><em>, </em><em>torch.Tensor</em><em>, </em><em>float</em><em>]</em><em>]</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>2-element tuple containing</p>
<ul class="simple">
<li><p>Samples satisfying the linear constraints.</p></li>
<li><p>Estimated proportion of samples satisfying the linear constraints.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Tuple[torch.Tensor, float]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.feasible_volume.get_outcome_feasibility_probability">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.feasible_volume.</span></span><span class="sig-name descname"><span class="pre">get_outcome_feasibility_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/feasible_volume.html#get_outcome_feasibility_probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.feasible_volume.get_outcome_feasibility_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo estimate of the feasible volume with respect to the outcome constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>botorch.models.model.Model</em></a>) – The model used for sampling the posterior.</p></li>
<li><p><strong>X</strong> (<em>torch.Tensor</em>) – A tensor of dimension <cite>batch-shape x 1 x d</cite>, where d is feature dimension.</p></li>
<li><p><strong>outcome_constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>torch.Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of dimension
<cite>sample_shape x batch-shape x q x m</cite> to a Tensor of dimension
<cite>sample_shape x batch-shape x q</cite>, where negative values imply feasibility.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – A lower limit for the probability of posterior samples feasibility.</p></li>
<li><p><strong>nsample_outcome</strong> (<em>int</em>) – The number of samples from the model posterior.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The seed for the posterior sampler. If omitted, use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Estimated proportion of features for which posterior samples satisfy
given outcome constraints with probability above or equal to
the given threshold.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.feasible_volume.estimate_feasible_volume">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.feasible_volume.</span></span><span class="sig-name descname"><span class="pre">estimate_feasible_volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample_feature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/feasible_volume.html#estimate_feasible_volume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.feasible_volume.estimate_feasible_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo estimate of the feasible volume with respect
to feature constraints and outcome constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>torch.Tensor</em>) – A <cite>2 x d</cite> tensor of lower and upper bounds
for each column of <cite>X</cite>.</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>botorch.models.model.Model</em></a>) – The model used for sampling the outcomes.</p></li>
<li><p><strong>outcome_constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>torch.Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of dimension
<cite>sample_shape x batch-shape x q x m</cite> to a Tensor of dimension
<cite>sample_shape x batch-shape x q</cite>, where negative values imply
feasibility.</p></li>
<li><p><strong>constraints</strong> (<em>inequality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>nsample_feature</strong> (<em>int</em>) – The number of feature samples satisfying the bounds.</p></li>
<li><p><strong>nsample_outcome</strong> (<em>int</em>) – The number of outcome samples from the model posterior.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – A lower limit for the probability of outcome feasibility</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The seed for both feature and outcome samplers. If omitted,
use a random seed.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – An indicator for whether to log the results.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Tuple</em><em>[</em><em>torch.Tensor</em><em>, </em><em>torch.Tensor</em><em>, </em><em>float</em><em>]</em><em>]</em><em>]</em>) – </p></li>
<li><p><strong>device</strong> (<em>Optional</em><em>[</em><em>torch.device</em><em>]</em>) – </p></li>
<li><p><strong>dtype</strong> (<em>Optional</em><em>[</em><em>torch.dtype</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><dl class="simple">
<dt>Estimated proportion of volume in feature space that is</dt><dd><p>feasible wrt the bounds and the inequality constraints (linear).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Estimated proportion of feasible features for which</dt><dd><p>posterior samples (outcome) satisfies the outcome constraints
with probability above the given threshold.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2-element tuple containing</p>
</dd>
</dl>
</dd></dl>
<section id="multi-objective-utilities">
<h3>Multi-Objective Utilities<a class="headerlink" href="#multi-objective-utilities" title="Permalink to this headline">¶</a></h3>
</section>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.box_decomposition">
<span id="abstract-box-decompositions"></span><h2>Abstract Box Decompositions<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.box_decomposition" title="Permalink to this headline">¶</a></h2>
<p>Box decomposition algorithms.</p>
<p>References</p>
<dl class="citation">
<dt class="label" id="lacour17"><span class="brackets">Lacour17</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>,<a href="#id4">3</a>,<a href="#id5">4</a>,<a href="#id12">5</a>,<a href="#id13">6</a>)</span></dt>
<dd><p>R. Lacour, K. Klamroth, C. Fonseca. A box decomposition algorithm to
compute the hypervolume indicator. Computers &amp; Operations Research,
Volume 79, 2017.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition.</span></span><span class="sig-name descname"><span class="pre">BoxDecomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>An abstract class for box decompositions.</p>
<p>Note: Internally, we store the negative reference point (minimization).</p>
<p>Initialize BoxDecomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>sort</strong> (<em>bool</em>) – A boolean indicating whether to sort the Pareto frontier.</p></li>
<li><p><strong>Y</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor of outcomes.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.pareto_Y">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">pareto_Y</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.pareto_Y" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns the non-dominated set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>n_pareto x m</cite>-dim tensor of outcomes.</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.ref_point">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">ref_point</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.ref_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reference point.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>m</cite>-dim tensor of outcomes.</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.Y">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.Y" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the raw outcomes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>n x m</cite>-dim tensor of outcomes.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.partition_space">
<span class="sig-name descname"><span class="pre">partition_space</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.partition_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.partition_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute box decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.get_hypercell_bounds">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.get_hypercell_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>2 x num_cells x num_outcomes</cite>-dim tensor containing the</dt><dd><p>lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update non-dominated front and decomposition.</p>
<p>By default, the partitioning is recomputed. Subclasses can override
this functionality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>torch.Tensor</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor of new, incremental outcomes.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset non-dominated front and decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.compute_hypervolume">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">compute_hypervolume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.compute_hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.compute_hypervolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute hypervolume that is dominated by the Pareto Froniter.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>(batch_shape)</cite>-dim tensor containing the hypervolume dominated by</dt><dd><p>each Pareto frontier.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition.</span></span><span class="sig-name descname"><span class="pre">FastPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#FastPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>A class for partitioning the (non-)dominated space into hyper-cells.</p>
<p>Note: this assumes maximization. Internally, it multiplies outcomes by -1
and performs the decomposition under minimization.</p>
<p>This class is abstract to support to two applications of Alg 1 from
<a class="reference internal" href="#lacour17" id="id2"><span>[Lacour17]</span></a>: 1) partitioning the space that is dominated by the Pareto
frontier and 2) partitioning the space that is not dominated by the
Pareto frontier.</p>
<p>Initialize FastPartitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#FastPartitioning.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update non-dominated front and decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>torch.Tensor</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor of new, incremental outcomes.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.partition_space">
<span class="sig-name descname"><span class="pre">partition_space</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#FastPartitioning.partition_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.partition_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute box decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.get_hypercell_bounds">
<span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#FastPartitioning.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.get_hypercell_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>2 x (batch_shape) x num_cells x m</cite>-dim tensor containing the</dt><dd><p>lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.box_decomposition_list">
<span id="box-decomposition-list"></span><h2>Box Decomposition List<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.box_decomposition_list" title="Permalink to this headline">¶</a></h2>
<p>Box decomposition container.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition_list.</span></span><span class="sig-name descname"><span class="pre">BoxDecompositionList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">box_decompositions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>A list of box decompositions.</p>
<p>Initialize the box decomposition list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*box_decompositions</strong> – An variable number of box decompositions</p></li>
<li><p><strong>box_decompositions</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition"><em>BoxDecomposition</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd1</span> <span class="o">=</span> <span class="n">FastNondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bd2</span> <span class="o">=</span> <span class="n">FastNondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">BoxDecompositionList</span><span class="p">(</span><span class="n">bd1</span><span class="p">,</span> <span class="n">bd2</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.pareto_Y">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">pareto_Y</span></span><em class="property"><span class="pre">:</span> <span class="pre">List[torch.Tensor]</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.pareto_Y" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns the non-dominated set.</p>
<p>Note: Internally, we store the negative pareto set (minimization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A list where the ith element is the <cite>n_pareto_i x m</cite>-dim tensor</dt><dd><p>of pareto optimal outcomes for each box_decomposition <cite>i</cite>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.ref_point">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">ref_point</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.ref_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reference point.</p>
<p>Note: Internally, we store the negative reference point (minimization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>n_box_decompositions x m</cite>-dim tensor of outcomes.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.get_hypercell_bounds">
<span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.get_hypercell_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>2 x n_box_decompositions x num_cells x num_outcomes</cite>-dim tensor</dt><dd><p>containing the lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the partitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>Union</em><em>[</em><em>List</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>torch.Tensor</em><em>]</em>) – A <cite>n_box_decompositions x n x num_outcomes</cite>-dim tensor or a list
where the ith  element contains the new points for
box_decomposition <cite>i</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.compute_hypervolume">
<span class="sig-name descname"><span class="pre">compute_hypervolume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList.compute_hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.compute_hypervolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute hypervolume that is dominated by the Pareto Froniter.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>(batch_shape)</cite>-dim tensor containing the hypervolume dominated by</dt><dd><p>each Pareto frontier.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.utils">
<span id="box-decomposition-utilities"></span><h2>Box Decomposition Utilities<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.utils" title="Permalink to this headline">¶</a></h2>
<p>Utilities for box decomposition algorithms.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.compute_local_upper_bounds">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">compute_local_upper_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#compute_local_upper_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_local_upper_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute local upper bounds.</p>
<p>Note: this assumes minimization.</p>
<p>This uses the incremental algorithm (Alg. 1) from <a class="reference internal" href="#lacour17" id="id3"><span>[Lacour17]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>torch.Tensor</em>) – A <cite>n x m</cite>-dim tensor containing the local upper bounds.</p></li>
<li><p><strong>Z</strong> (<em>torch.Tensor</em>) – A <cite>n x m x m</cite>-dim tensor containing the defining points.</p></li>
<li><p><strong>z</strong> (<em>torch.Tensor</em>) – A <cite>m</cite>-dim tensor containing the new point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A new <cite>n’ x m</cite>-dim tensor local upper bounds.</p></li>
<li><p>A <cite>n’ x m x m</cite>-dim tensor containing the defining points.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2-element tuple containing</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.get_partition_bounds">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">get_partition_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#get_partition_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.get_partition_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the cell bounds given the local upper bounds and the defining points.</p>
<p>This implements Equation 2 in <a class="reference internal" href="#lacour17" id="id4"><span>[Lacour17]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Z</strong> (<em>torch.Tensor</em>) – A <cite>n x m x m</cite>-dim tensor containing the defining points. The first
dimension corresponds to u_idx, the second dimension corresponds to j,
and Z[u_idx, j] is the set of definining points Z^j(u) where
u = U[u_idx].</p></li>
<li><p><strong>U</strong> (<em>torch.Tensor</em>) – A <cite>n x m</cite>-dim tensor containing the local upper bounds.</p></li>
<li><p><strong>ref_point</strong> (<em>torch.Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>2 x num_cells x m</cite>-dim tensor containing the lower and upper vertices</dt><dd><p>bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.update_local_upper_bounds_incremental">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">update_local_upper_bounds_incremental</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_pareto_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#update_local_upper_bounds_incremental"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.update_local_upper_bounds_incremental" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the current local upper with the new pareto points.</p>
<p>This assumes minimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_pareto_Y</strong> (<em>torch.Tensor</em>) – A <cite>n x m</cite>-dim tensor containing the new
Pareto points.</p></li>
<li><p><strong>U</strong> (<em>torch.Tensor</em>) – A <cite>n’ x m</cite>-dim tensor containing the local upper bounds.</p></li>
<li><p><strong>Z</strong> (<em>torch.Tensor</em>) – A <cite>n x m x m</cite>-dim tensor containing the defining points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A new <cite>n’ x m</cite>-dim tensor local upper bounds.</p></li>
<li><p>A <cite>n’ x m x m</cite>-dim tensor containing the defining points</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2-element tuple containing</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.compute_non_dominated_hypercell_bounds_2d">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">compute_non_dominated_hypercell_bounds_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y_sorted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#compute_non_dominated_hypercell_bounds_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_non_dominated_hypercell_bounds_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an axis-aligned partitioning of the non-dominated space for 2 objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pareto_Y_sorted</strong> (<em>torch.Tensor</em>) – A <cite>(batch_shape) x n_pareto x 2</cite>-dim tensor of pareto outcomes
that are sorted by the 0th dimension in increasing order. All points must be
better than the reference point.</p></li>
<li><p><strong>ref_point</strong> (<em>torch.Tensor</em>) – A <cite>(batch_shape) x 2</cite>-dim reference point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>2 x (batch_shape) x n_pareto + 1 x m</cite>-dim tensor of cell bounds.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.compute_dominated_hypercell_bounds_2d">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">compute_dominated_hypercell_bounds_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y_sorted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#compute_dominated_hypercell_bounds_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_dominated_hypercell_bounds_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an axis-aligned partitioning of the dominated space for 2-objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pareto_Y_sorted</strong> (<em>torch.Tensor</em>) – A <cite>(batch_shape) x n_pareto x 2</cite>-dim tensor of pareto outcomes
that are sorted by the 0th dimension in increasing order.</p></li>
<li><p><strong>ref_point</strong> (<em>torch.Tensor</em>) – A <cite>2</cite>-dim reference point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>2 x (batch_shape) x n_pareto x m</cite>-dim tensor of cell bounds.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.box_decomposition">
<span id="box-decompositions-deprecated-use-botorch-utils-multi-objective-box-decompositions"></span><h2>Box Decompositions [DEPRECATED - use botorch..utils.multi_objective.box_decompositions]<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decomposition" title="Permalink to this headline">¶</a></h2>
<p>DEPRECATED - Box decomposition algorithms.
Use the botorch.utils.multi_objective.box_decompositions instead.</p>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.dominated">
<span id="dominated-partitionings"></span><h2>Dominated Partitionings<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.dominated" title="Permalink to this headline">¶</a></h2>
<p>Algorithms for partitioning the dominated space into hyperrectangles.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.dominated.</span></span><span class="sig-name descname"><span class="pre">DominatedPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/dominated.html#DominatedPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning</span></code></a></p>
<p>Partition dominated space into axis-aligned hyperrectangles.</p>
<p>This uses the Algorithm 1 from <a class="reference internal" href="#lacour17" id="id5"><span>[Lacour17]</span></a>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">DominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialize FastPartitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning.compute_hypervolume">
<span class="sig-name descname"><span class="pre">compute_hypervolume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/dominated.html#DominatedPartitioning.compute_hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning.compute_hypervolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute hypervolume that is dominated by the Pareto Frontier.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>(batch_shape)</cite>-dim tensor containing the hypervolume dominated by</dt><dd><p>each Pareto frontier.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.hypervolume">
<span id="hypervolume"></span><h2>Hypervolume<a class="headerlink" href="#module-botorch.utils.multi_objective.hypervolume" title="Permalink to this headline">¶</a></h2>
<p>Hypervolume Utilities.</p>
<p>References</p>
<dl class="citation">
<dt class="label" id="fonseca2006"><span class="brackets">Fonseca2006</span><span class="fn-backref">(<a href="#id7">1</a>,<a href="#id8">2</a>)</span></dt>
<dd><p>C. M. Fonseca, L. Paquete, and M. Lopez-Ibanez. An improved dimension-sweep
algorithm for the hypervolume indicator. In IEEE Congress on Evolutionary
Computation, pages 1157-1163, Vancouver, Canada, July 2006.</p>
</dd>
<dt class="label" id="ishibuchi2011"><span class="brackets"><a class="fn-backref" href="#id6">Ishibuchi2011</a></span></dt>
<dd><p>H. Ishibuchi, N. Akedo, and Y. Nojima. A many-objective test problem
for visually examining diversity maintenance behavior in a decision
space. Proc. 13th Annual Conf. Genetic Evol. Comput., 2011.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.infer_reference_point">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">infer_reference_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_ref_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_max_ref_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#infer_reference_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.infer_reference_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get reference point for hypervolume computations.</p>
<p>This sets the reference point to be <cite>ref_point = nadir - 0.1 * range</cite>
when there is no pareto_Y that is better than the reference point.</p>
<p><a class="reference internal" href="#ishibuchi2011" id="id6"><span>[Ishibuchi2011]</span></a> find 0.1 to be a robust multiplier for scaling the
nadir point.</p>
<p>Note: this assumes maximization of all objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pareto_Y</strong> (<em>torch.Tensor</em>) – A <cite>n x m</cite>-dim tensor of Pareto-optimal points.</p></li>
<li><p><strong>max_ref_point</strong> (<em>Optional</em><em>[</em><em>torch.Tensor</em><em>]</em>) – A <cite>m</cite> dim tensor indicating the maximum reference point.</p></li>
<li><p><strong>scale</strong> (<em>float</em>) – A multiplier used to scale back the reference point based on the
range of each objective.</p></li>
<li><p><strong>scale_max_ref_point</strong> (<em>bool</em>) – A boolean indicating whether to apply scaling to
the max_ref_point based on the range of each objective.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>m</cite>-dim tensor containing the reference point.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Hypervolume">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">Hypervolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#Hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Hypervolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Hypervolume computation dimension sweep algorithm from <a class="reference internal" href="#fonseca2006" id="id7"><span>[Fonseca2006]</span></a>.</p>
<p>Adapted from Simon Wessing’s implementation of the algorithm
(Variant 3, Version 1.2) in <a class="reference internal" href="#fonseca2006" id="id8"><span>[Fonseca2006]</span></a> in PyMOO:
<a class="reference external" href="https://github.com/msu-coinlab/pymoo/blob/master/pymoo/vendor/hv.py">https://github.com/msu-coinlab/pymoo/blob/master/pymoo/vendor/hv.py</a></p>
<p>Maximization is assumed.</p>
<p>TODO: write this in C++ for faster looping.</p>
<p>Initialize hypervolume object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ref_point</strong> (<em>Tensor</em>) – <cite>m</cite>-dim Tensor containing the reference point.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Hypervolume.ref_point">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">ref_point</span></span><em class="property"><span class="pre">:</span> <span class="pre">torch.Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Hypervolume.ref_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get reference point (for maximization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>m</cite>-dim tensor containing the reference point.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Hypervolume.compute">
<span class="sig-name descname"><span class="pre">compute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#Hypervolume.compute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Hypervolume.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute hypervolume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pareto_Y</strong> (<em>torch.Tensor</em>) – A <cite>n x m</cite>-dim tensor of pareto optimal outcomes</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The hypervolume.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.sort_by_dimension">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">sort_by_dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#sort_by_dimension"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.sort_by_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the list of nodes in-place by the specified objective.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes</strong> (<em>List</em><em>[</em><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>botorch.utils.multi_objective.hypervolume.Node</em></a><em>]</em>) – A list of Nodes</p></li>
<li><p><strong>i</strong> (<em>int</em>) – The index of the objective to sort by</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Node">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">Node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#Node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Node in the MultiList data structure.</p>
<p>Initialize MultiList.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – The number of objectives</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em>) – The dtype</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – The device</p></li>
<li><p><strong>data</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – The tensor data to be stored in this Node.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">MultiList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A special data structure used in hypervolume computation.</p>
<p>It consists of several doubly linked lists that share common nodes.
Every node has multiple predecessors and successors, one in every list.</p>
<p>Initialize <cite>m</cite> doubly linked lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – number of doubly linked lists</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em>) – the dtype</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – the device</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends a node to the end of the list at the given index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>botorch.utils.multi_objective.hypervolume.Node</em></a>) – the new node</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the index where the node should be appended.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.extend"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends the list at the given index with the nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes</strong> (<em>List</em><em>[</em><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>botorch.utils.multi_objective.hypervolume.Node</em></a><em>]</em>) – list of nodes to append at the given index.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the index where the nodes should be appended.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.remove"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes and returns ‘node’ from all lists in [0, ‘index’].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>botorch.utils.multi_objective.hypervolume.Node</em></a>) – The node to remove</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The upper bound on the range of indices</p></li>
<li><p><strong>bounds</strong> (<em>torch.Tensor</em>) – A <cite>2 x m</cite>-dim tensor bounds on the objectives</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node">botorch.utils.multi_objective.hypervolume.Node</a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.reinsert">
<span class="sig-name descname"><span class="pre">reinsert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.reinsert"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.reinsert" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-inserts the node at its original position.</p>
<p>Re-inserts the node at its original position in all lists in [0, ‘index’]
before it was removed. This method assumes that the next and previous
nodes of the node that is reinserted are in the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>botorch.utils.multi_objective.hypervolume.Node</em></a>) – The node</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The upper bound on the range of indices</p></li>
<li><p><strong>bounds</strong> (<em>torch.Tensor</em>) – A <cite>2 x m</cite>-dim tensor bounds on the objectives</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.non_dominated">
<span id="non-dominated-partitionings"></span><h2>Non-dominated Partitionings<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.non_dominated" title="Permalink to this headline">¶</a></h2>
<p>Algorithms for partitioning the non-dominated space into rectangles.</p>
<p>References</p>
<dl class="citation">
<dt class="label" id="couckuyt2012"><span class="brackets">Couckuyt2012</span><span class="fn-backref">(<a href="#id9">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p>I. Couckuyt, D. Deschrijver and T. Dhaene, “Towards Efficient
Multiobjective Optimization: Multiobjective statistical criterions,”
2012 IEEE Congress on Evolutionary Computation, Brisbane, QLD, 2012,
pp. 1-8.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.non_dominated.</span></span><span class="sig-name descname"><span class="pre">NondominatedPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#NondominatedPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition</span></code></a></p>
<p>A class for partitioning the non-dominated space into hyper-cells.</p>
<p>Note: this assumes maximization. Internally, it multiplies outcomes by -1 and
performs the decomposition under minimization. TODO: use maximization
internally as well.</p>
<p>Note: it is only feasible to use this algorithm to compute an exact
decomposition of the non-dominated space for <cite>m&lt;5</cite> objectives (alpha=0.0).</p>
<p>The alpha parameter can be increased to obtain an approximate partitioning
faster. The <cite>alpha</cite> is a fraction of the total hypervolume encapsuling the
entire Pareto set. When a hypercell’s volume divided by the total hypervolume
is less than <cite>alpha</cite>, we discard the hypercell. See Figure 2 in
<a class="reference internal" href="#couckuyt2012" id="id9"><span>[Couckuyt2012]</span></a> for a visual representation.</p>
<p>This PyTorch implementation of the binary partitioning algorithm (<a class="reference internal" href="#couckuyt2012" id="id10"><span>[Couckuyt2012]</span></a>)
is adapted from numpy/tensorflow implementation at:
<a class="reference external" href="https://github.com/GPflow/GPflowOpt/blob/master/gpflowopt/pareto.py">https://github.com/GPflow/GPflowOpt/blob/master/gpflowopt/pareto.py</a>.</p>
<p>TODO: replace this with a more efficient decomposition. E.g.
<a class="reference external" href="https://link.springer.com/content/pdf/10.1007/s10898-019-00798-7.pdf">https://link.springer.com/content/pdf/10.1007/s10898-019-00798-7.pdf</a></p>
<p>Initialize NondominatedPartitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – A thresold fraction of total volume used in an approximate
decomposition.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">NondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.get_hypercell_bounds">
<span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#NondominatedPartitioning.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.get_hypercell_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ref_point</strong> – A <cite>(batch_shape) x m</cite>-dim tensor containing the reference point.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>2 x num_cells x m</cite>-dim tensor containing the</dt><dd><p>lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.compute_hypervolume">
<span class="sig-name descname"><span class="pre">compute_hypervolume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#NondominatedPartitioning.compute_hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.compute_hypervolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the hypervolume for the given reference point.</p>
<p>This method computes the hypervolume of the non-dominated space
and computes the difference between the hypervolume between the
ideal point and hypervolume of the non-dominated space.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><cite>(batch_shape)</cite>-dim tensor containing the dominated hypervolume.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.non_dominated.</span></span><span class="sig-name descname"><span class="pre">FastNondominatedPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#FastNondominatedPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning"><code class="xref py py-class docutils literal notranslate"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning</span></code></a></p>
<p>A class for partitioning the non-dominated space into hyper-cells.</p>
<p>Note: this assumes maximization. Internally, it multiplies by -1 and performs
the decomposition under minimization.</p>
<p>This class is far more efficient than NondominatedPartitioning for exact box
partitionings</p>
<dl class="simple">
<dt>This class uses the two-step approach similar to that in <a class="reference internal" href="acquisition.html#yang2019" id="id11"><span>[Yang2019]</span></a>, where:</dt><dd><ol class="loweralpha simple">
<li><dl class="simple">
<dt>first, Alg 1 from <a class="reference internal" href="#lacour17" id="id12"><span>[Lacour17]</span></a> is used to find the local lower bounds</dt><dd><p>for the maximization problem</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>second, the local lower bounds are used as the Pareto frontier for the</dt><dd><p>minimization problem, and <a class="reference internal" href="#lacour17" id="id13"><span>[Lacour17]</span></a> is applied again to partition
the space dominated by that Pareto frontier.</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<p>Initialize FastNondominatedPartitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">FastNondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning.compute_hypervolume">
<span class="sig-name descname"><span class="pre">compute_hypervolume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#FastNondominatedPartitioning.compute_hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning.compute_hypervolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute hypervolume that is dominated by the Pareto Froniter.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>(batch_shape)</cite>-dim tensor containing the hypervolume dominated by</dt><dd><p>each Pareto frontier.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.pareto">
<span id="pareto"></span><h2>Pareto<a class="headerlink" href="#module-botorch.utils.multi_objective.pareto" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.pareto.is_non_dominated">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.pareto.</span></span><span class="sig-name descname"><span class="pre">is_non_dominated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deduplicate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/pareto.html#is_non_dominated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.pareto.is_non_dominated" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the non-dominated front.</p>
<p>Note: this assumes maximization.</p>
<p>For small <cite>n</cite>, this method uses a highly parallel methodology
that compares all pairs of points in Y. However, this is memory
intensive and slow for large <cite>n</cite>. For large <cite>n</cite> (or if Y is larger
than 5MB), this method will dispatch to a loop-based approach
that is faster and has a lower memory footprint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Y</strong> (<em>torch.Tensor</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor of outcomes.</p></li>
<li><p><strong>deduplicate</strong> (<em>bool</em>) – A boolean indicating whether to only return
unique points on the pareto frontier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <cite>(batch_shape) x n</cite>-dim boolean tensor indicating whether
each point is non-dominated.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.scalarization">
<span id="scalarization"></span><h2>Scalarization<a class="headerlink" href="#module-botorch.utils.multi_objective.scalarization" title="Permalink to this headline">¶</a></h2>
<p>Helper utilities for constructing scalarizations.</p>
<p>References</p>
<dl class="citation">
<dt class="label" id="knowles2005"><span class="brackets">Knowles2005</span><span class="fn-backref">(<a href="#id14">1</a>,<a href="#id16">2</a>)</span></dt>
<dd><p>J. Knowles, “ParEGO: a hybrid algorithm with on-line landscape approximation
for expensive multiobjective optimization problems,” in IEEE Transactions
on Evolutionary Computation, vol. 10, no. 1, pp. 50-66, Feb. 2006.</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.scalarization.get_chebyshev_scalarization">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.scalarization.</span></span><span class="sig-name descname"><span class="pre">get_chebyshev_scalarization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/scalarization.html#get_chebyshev_scalarization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.scalarization.get_chebyshev_scalarization" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an augmented Chebyshev scalarization.</p>
<p>Outcomes are first normalized to [0,1] and then an augmented
Chebyshev scalarization is applied.</p>
<dl class="simple">
<dt>Augmented Chebyshev scalarization:</dt><dd><p>objective(y) = min(w * y) + alpha * sum(w * y)</p>
</dd>
</dl>
<p>Note: this assumes maximization.</p>
<p>See <a class="reference internal" href="#knowles2005" id="id14"><span>[Knowles2005]</span></a> for details.</p>
<p>This scalarization can be used with qExpectedImprovement to implement q-ParEGO
as proposed in <a class="reference internal" href="acquisition.html#daulton2020qehvi" id="id15"><span>[Daulton2020qehvi]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>torch.Tensor</em>) – A <cite>m</cite>-dim tensor of weights.</p></li>
<li><p><strong>Y</strong> (<em>torch.Tensor</em>) – A <cite>n x m</cite>-dim tensor of observed outcomes, which are used for
scaling the outcomes to [0,1].</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Parameter governing the influence of the weighted sum term. The
default value comes from <a class="reference internal" href="#knowles2005" id="id16"><span>[Knowles2005]</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Transform function using the objective weights.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Callable[[torch.Tensor, Optional[torch.Tensor]], torch.Tensor]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span> <span class="o">=</span> <span class="n">get_aug_chebyshev_scalarization</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</section>
</section>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">BoTorch</a></h1>
<h3>Navigation</h3>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="acquisition.html">botorch.acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">botorch.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="generation.html">botorch.generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="posteriors.html">botorch.posteriors</a></li>
<li class="toctree-l1"><a class="reference internal" href="optim.html">botorch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="fit.html">botorch.fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">botorch.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="cross_validation.html">botorch.cross_validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="settings.html">botorch.settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">botorch.logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="test_functions.html">botorch.test_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="exceptions.html">botorch.exceptions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">botorch.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributions.html">botorch.distributions</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="index.html">Documentation overview</a><ul>
<li>Previous: <a href="exceptions.html" title="previous chapter">botorch.exceptions</a></li>
<li>Next: <a href="distributions.html" title="next chapter">botorch.distributions</a></li>
</ul></li>
</ul>
</div>
<div id="searchbox" role="search" style="display: none">
<h3 id="searchlabel">Quick search</h3>
<div class="searchformwrapper">
<form action="search.html" class="search" method="get">
<input aria-labelledby="searchlabel" name="q" type="text"/>
<input type="submit" value="Go"/>
</form>
</div>
</div>
<script>$('#searchbox').show(0);</script>
</div>
</div>
<div class="clearer"></div>
</div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/v/0.5.0/" class="nav-home"><img src="/v/0.5.0/img/botorch.png" alt="BoTorch" width="66" height="58"/></a><div class="footerSection"><h5>Docs</h5><a href="/v/0.5.0/docs/introduction">Introduction</a><a href="/v/0.5.0/docs/getting_started">Getting Started</a><a href="/v/0.5.0/tutorials/">Tutorials</a><a href="/v/0.5.0/api/">API Reference</a><a href="https://arxiv.org/abs/1910.06403">Paper</a></div><div class="footerSection"><h5>Legal</h5><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noreferrer noopener">Privacy</a><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noreferrer noopener">Terms</a></div><div class="footerSection"><h5>Social</h5><div class="social"><a class="github-button" href="https://github.com/pytorch/botorch" data-count-href="https://github.com/pytorch/botorch/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star BoTorch on GitHub">botorch</a></div></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/v/0.5.0/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright"> Copyright © 2021 Facebook Inc.</section><script>
            (function() {
              var BAD_BASE = '/botorch/';
              if (window.location.origin !== 'https://botorch.org') {
                var pathname = window.location.pathname;
                var newPathname = pathname.slice(pathname.indexOf(BAD_BASE) === 0 ? BAD_BASE.length : 1);
                var newLocation = 'https://botorch.org/v/0.5.0/' + newPathname;
                console.log('redirecting to ' + newLocation);
                window.location.href = newLocation;
              }
            })();
          </script></footer></div></body></html>