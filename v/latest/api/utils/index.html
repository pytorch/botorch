<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>BoTorch · Bayesian Optimization in PyTorch</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Bayesian Optimization in PyTorch"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="BoTorch · Bayesian Optimization in PyTorch"/><meta property="og:type" content="website"/><meta property="og:url" content="https://botorch.org/v/latest/"/><meta property="og:description" content="Bayesian Optimization in PyTorch"/><meta property="og:image" content="https://botorch.org/v/latest/img/botorch.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://botorch.org/v/latest/img/botorch.png"/><link rel="shortcut icon" href="/v/latest/img/botorch.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-CXN3PGE3CC"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'G-CXN3PGE3CC');
            </script><link rel="stylesheet" href="/v/latest/css/code_block_buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/v/latest/js/code_block_buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/v/latest/js/mathjax.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/v/latest/js/scrollSpy.js"></script><link rel="stylesheet" href="/v/latest/css/main.css"/><script src="/v/latest/js/codetabs.js"></script></head><body><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/v/latest/"><img class="logo" src="/v/latest/img/botorch_logo_lockup_white.png" alt="BoTorch"/><h2 class="headerTitleWithLogo">BoTorch</h2></a><a href="/v/latest/versions"><h3>latest</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/v/latest/docs/introduction" target="_self">Docs</a></li><li class=""><a href="/v/latest/tutorials/" target="_self">Tutorials</a></li><li class=""><a href="/v/latest/api/" target="_self">API Reference</a></li><li class=""><a href="/v/latest/docs/papers" target="_self">Papers</a></li><li class=""><a href="https://github.com/pytorch/botorch" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div>
<script type="text/javascript" id="documentation_options" data-url_root="./" src="/js/documentation_options.js"></script>
<script type="text/javascript" src="/js/jquery.js"></script>
<script type="text/javascript" src="/js/underscore.js"></script>
<script type="text/javascript" src="/js/doctools.js"></script>
<script type="text/javascript" src="/js/language_data.js"></script>
<script type="text/javascript" src="/js/searchtools.js"></script>
<div class="sphinx"><div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body" role="main">
<section id="module-botorch.utils">
<span id="botorch-utils"></span><h1>botorch.utils<a class="headerlink" href="#module-botorch.utils" title="Permalink to this heading">¶</a></h1>
<section id="module-botorch.utils.constraints">
<span id="constraints"></span><h2>Constraints<a class="headerlink" href="#module-botorch.utils.constraints" title="Permalink to this heading">¶</a></h2>
<p>Helpers for handling input or outcome constraints.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.constraints.get_outcome_constraint_transforms">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.constraints.</span></span><span class="sig-name descname"><span class="pre">get_outcome_constraint_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outcome_constraints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#get_outcome_constraint_transforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.get_outcome_constraint_transforms" title="Permalink to this definition">¶</a></dt>
<dd><p>Create outcome constraint callables from outcome constraint tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>outcome_constraints</strong> (<em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – A tuple of <cite>(A, b)</cite>. For <cite>k</cite> outcome constraints
and <cite>m</cite> outputs at <cite>f(x)`</cite>, <cite>A</cite> is <cite>k x m</cite> and <cite>b</cite> is <cite>k x 1</cite> such
that <cite>A f(x) &lt;= b</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of callables, each mapping a Tensor of size <cite>b x q x m</cite> to a
tensor of size <cite>b x q</cite>, where <cite>m</cite> is the number of outputs of the model.
Negative values imply feasibility. The callables support broadcasting
(e.g. for calling on a tensor of shape <cite>mc_samples x b x q x m</cite>).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>List</em>[<em>Callable</em>[[<em>Tensor</em>], <em>Tensor</em>]] | None</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># constrain `f(x)[0] &lt;= 0`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outcome_constraints</span> <span class="o">=</span> <span class="n">get_outcome_constraint_transforms</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.constraints.get_monotonicity_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.constraints.</span></span><span class="sig-name descname"><span class="pre">get_monotonicity_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#get_monotonicity_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.get_monotonicity_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a system of linear inequalities <cite>(A, b)</cite> that generically encodes order
constraints on the elements of a <cite>d</cite>-dimsensional space, i.e. <cite>A @ x &lt; b</cite> implies
<cite>x[i] &lt; x[i + 1]</cite> for a <cite>d</cite>-dimensional vector <cite>x</cite>.</p>
<p>Idea: Could encode <cite>A</cite> as sparse matrix, if it is supported well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – Dimensionality of the constraint space, i.e. number of monotonic parameters.</p></li>
<li><p><strong>descending</strong> (<em>bool</em>) – If True, forces the elements of a vector to be monotonically de-
creasing and be monotonically increasing otherwise.</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – The dtype of the returned Tensors.</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – The device of the returned Tensors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple of Tensors <cite>(A, b)</cite> representing the monotonicity constraint as a system
of linear inequalities <cite>A @ x &lt; b</cite>. <cite>A</cite> is <cite>(d - 1) x d</cite>-dimensional and <cite>b</cite> is
<cite>(d - 1) x 1</cite>-dimensional.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tuple</em>[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.containers">
<span id="containers"></span><h2>Containers<a class="headerlink" href="#module-botorch.utils.containers" title="Permalink to this heading">¶</a></h2>
<p>Representations for different kinds of data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.containers.</span></span><span class="sig-name descname"><span class="pre">DenseContainer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/containers.html#DenseContainer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.containers.DenseContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BotorchContainer</span></code></p>
<p>Basic representation of data stored as a dense Tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>event_shape</strong> (<em>Size</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.values">
<span class="sig-name descname"><span class="pre">values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.event_shape">
<span class="sig-name descname"><span class="pre">event_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.event_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.device">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">device</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.containers.</span></span><span class="sig-name descname"><span class="pre">SliceContainer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/containers.html#SliceContainer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.containers.SliceContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BotorchContainer</span></code></p>
<p>Represent data points formed by concatenating (n-1)-dimensional slices
taken from the leading dimension of an n-dimensional source tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>indices</strong> (<em>LongTensor</em>) – </p></li>
<li><p><strong>event_shape</strong> (<em>Size</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.values">
<span class="sig-name descname"><span class="pre">values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">LongTensor</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.event_shape">
<span class="sig-name descname"><span class="pre">event_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.event_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.device">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">device</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.context_managers">
<span id="context-managers"></span><h2>Context Managers<a class="headerlink" href="#module-botorch.utils.context_managers" title="Permalink to this heading">¶</a></h2>
<p>Utilities for optimization.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.context_managers.TensorCheckpoint">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">TensorCheckpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#TensorCheckpoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.TensorCheckpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">NamedTuple</span></code></p>
<p>Create new instance of TensorCheckpoint(values, device, dtype)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – </p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.context_managers.TensorCheckpoint.values">
<span class="sig-name descname"><span class="pre">values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.context_managers.TensorCheckpoint.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.context_managers.TensorCheckpoint.device">
<span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">device</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.context_managers.TensorCheckpoint.device" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.context_managers.TensorCheckpoint.dtype">
<span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.context_managers.TensorCheckpoint.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.context_managers.delattr_ctx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">delattr_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enforce_hasattr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#delattr_ctx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.delattr_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Contextmanager for temporarily deleting attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>instance</strong> (<em>object</em>) – </p></li>
<li><p><strong>attrs</strong> (<em>str</em>) – </p></li>
<li><p><strong>enforce_hasattr</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Generator</em>[None, None, None]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.context_managers.requires_grad_ctx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">requires_grad_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assignments</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#requires_grad_ctx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.requires_grad_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Contextmanager for temporarily setting the requires_grad field of a module’s
parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> (<em>Module</em>) – </p></li>
<li><p><strong>assignments</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>bool</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Generator</em>[None, None, None]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.context_managers.parameter_rollback_ctx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">parameter_rollback_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#parameter_rollback_ctx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.parameter_rollback_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Contextmanager that exits by rolling back a module’s state_dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – Module instance.</p></li>
<li><p><strong>name_filter</strong> – Optional Boolean function used to filter items by name.</p></li>
<li><p><strong>checkpoint</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint" title="botorch.utils.context_managers.TensorCheckpoint"><em>TensorCheckpoint</em></a><em>] </em><em>| </em><em>None</em>) – Optional cache of values and tensor metadata specifying the rollback
state for the module (or some subset thereof).</p></li>
<li><p><strong>**tkwargs</strong> (<em>Any</em>) – Keyword arguments passed to <cite>torch.Tensor.to</cite> when copying data from
each tensor in <cite>module.state_dict()</cite> to the internally created checkpoint.
Only adhered to when the <cite>checkpoint</cite> argument is None.</p></li>
<li><p><strong>parameters</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>Tensor</em><em>]</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary of TensorCheckpoints for the module’s state_dict. Any in-places
changes to the checkpoint will be observed at rollback time. If the checkpoint
is cleared, no rollback will occur.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Generator</em>[<em>Dict</em>[str, <a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint" title="botorch.utils.context_managers.TensorCheckpoint"><em>TensorCheckpoint</em></a>], None, None]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.context_managers.module_rollback_ctx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">module_rollback_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#module_rollback_ctx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.module_rollback_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Contextmanager that exits by rolling back a module’s state_dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> (<em>Module</em>) – Module instance.</p></li>
<li><p><strong>name_filter</strong> (<em>Callable</em><em>[</em><em>[</em><em>str</em><em>]</em><em>, </em><em>bool</em><em>] </em><em>| </em><em>None</em>) – Optional Boolean function used to filter items by name.</p></li>
<li><p><strong>checkpoint</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint" title="botorch.utils.context_managers.TensorCheckpoint"><em>TensorCheckpoint</em></a><em>] </em><em>| </em><em>None</em>) – Optional cache of values and tensor metadata specifying the rollback
state for the module (or some subset thereof).</p></li>
<li><p><strong>**tkwargs</strong> (<em>Any</em>) – Keyword arguments passed to <cite>torch.Tensor.to</cite> when copying data from
each tensor in <cite>module.state_dict()</cite> to the internally created checkpoint.
Only adhered to when the <cite>checkpoint</cite> argument is None.</p></li>
</ul>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary of TensorCheckpoints for the module’s state_dict. Any in-places
changes to the checkpoint will be observed at rollback time. If the checkpoint
is cleared, no rollback will occur.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Generator</em>[<em>Dict</em>[str, <a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint" title="botorch.utils.context_managers.TensorCheckpoint"><em>TensorCheckpoint</em></a>], None, None]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.context_managers.zero_grad_ctx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">zero_grad_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_on_enter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_on_exit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#zero_grad_ctx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.zero_grad_ctx" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parameters</strong> (<em>Dict</em><em>[</em><em>str</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>Iterable</em><em>[</em><em>Tensor</em><em>]</em>) – </p></li>
<li><p><strong>zero_on_enter</strong> (<em>bool</em>) – </p></li>
<li><p><strong>zero_on_exit</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Generator</em>[None, None, None]</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.datasets">
<span id="datasets"></span><h2>Datasets<a class="headerlink" href="#module-botorch.utils.datasets" title="Permalink to this heading">¶</a></h2>
<p>Representations for different kinds of datasets.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.datasets.</span></span><span class="sig-name descname"><span class="pre">SupervisedDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Yvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#SupervisedDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for datasets consisting of labelled pairs <cite>(X, Y)</cite>
and an optional <cite>Yvar</cite> that stipulates observations variances so
that <cite>Y[i] ~ N(f(X[i]), Yvar[i])</cite>.</p>
<p>This class object’s <cite>__init__</cite> method converts Tensors <cite>src</cite> to
DenseContainers under the assumption that <cite>event_shape=src.shape[-1:]</cite>.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">SupervisedDataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">SupervisedDataset</span><span class="p">(</span>
    <span class="n">DenseContainer</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">event_shape</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]),</span>
    <span class="n">DenseContainer</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">event_shape</span><span class="o">=</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]),</span>
<span class="p">)</span>
<span class="k">assert</span> <span class="n">A</span> <span class="o">==</span> <span class="n">B</span>
</pre></div>
</div>
<p>Constructs a <cite>SupervisedDataset</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>BotorchContainer</em>) – A <cite>Tensor</cite> or <cite>BotorchContainer</cite> representing the input features.</p></li>
<li><p><strong>Y</strong> (<em>BotorchContainer</em>) – A <cite>Tensor</cite> or <cite>BotorchContainer</cite> representing the outcomes.</p></li>
<li><p><strong>Yvar</strong> (<em>BotorchContainer</em><em> | </em><em>None</em>) – An optional <cite>Tensor</cite> or <cite>BotorchContainer</cite> representing
the observation noise.</p></li>
<li><p><strong>validate_init</strong> (<em>bool</em>) – If <cite>True</cite>, validates the input shapes.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset.X">
<span class="sig-name descname"><span class="pre">X</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">BotorchContainer</span></em><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset.X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset.Y">
<span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">BotorchContainer</span></em><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset.Y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset.Yvar">
<span class="sig-name descname"><span class="pre">Yvar</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">BotorchContainer</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset.Yvar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset.dict_from_iter">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_from_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Yvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#SupervisedDataset.dict_from_iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset.dict_from_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of <cite>SupervisedDataset</cite> from iterables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>BotorchContainer</em><em> | </em><em>Tensor</em><em> | </em><em>Iterable</em><em>[</em><em>BotorchContainer</em><em> | </em><em>Tensor</em><em>]</em>) – </p></li>
<li><p><strong>Y</strong> (<em>BotorchContainer</em><em> | </em><em>Tensor</em><em> | </em><em>Iterable</em><em>[</em><em>BotorchContainer</em><em> | </em><em>Tensor</em><em>]</em>) – </p></li>
<li><p><strong>Yvar</strong> (<em>BotorchContainer</em><em> | </em><em>Tensor</em><em> | </em><em>Iterable</em><em>[</em><em>BotorchContainer</em><em> | </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – </p></li>
<li><p><strong>keys</strong> (<em>Iterable</em><em>[</em><em>Hashable</em><em>] </em><em>| </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Dict</em>[<em>Hashable</em>, <a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><em>SupervisedDataset</em></a>]</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.datasets.FixedNoiseDataset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.datasets.</span></span><span class="sig-name descname"><span class="pre">FixedNoiseDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Yvar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#FixedNoiseDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.FixedNoiseDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupervisedDataset</span></code></a></p>
<p>A SupervisedDataset with an additional field <cite>Yvar</cite> that stipulates
observations variances so that <cite>Y[i] ~ N(f(X[i]), Yvar[i])</cite>.</p>
<p>NOTE: This is deprecated. Use <cite>SupervisedDataset</cite> instead.</p>
<p>Initialize a <cite>FixedNoiseDataset</cite> – deprecated!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>BotorchContainer</em>) – </p></li>
<li><p><strong>Y</strong> (<em>BotorchContainer</em>) – </p></li>
<li><p><strong>Yvar</strong> (<em>BotorchContainer</em><em> | </em><em>None</em>) – </p></li>
<li><p><strong>validate_init</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.datasets.FixedNoiseDataset.X">
<span class="sig-name descname"><span class="pre">X</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">BotorchContainer</span></em><a class="headerlink" href="#botorch.utils.datasets.FixedNoiseDataset.X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.datasets.FixedNoiseDataset.Y">
<span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">BotorchContainer</span></em><a class="headerlink" href="#botorch.utils.datasets.FixedNoiseDataset.Y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.datasets.FixedNoiseDataset.Yvar">
<span class="sig-name descname"><span class="pre">Yvar</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">BotorchContainer</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.datasets.FixedNoiseDataset.Yvar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.datasets.RankingDataset">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.datasets.</span></span><span class="sig-name descname"><span class="pre">RankingDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#RankingDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.RankingDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupervisedDataset</span></code></a></p>
<p>A SupervisedDataset whose labelled pairs <cite>(x, y)</cite> consist of m-ary combinations
<cite>x ∈ Z^{m}</cite> of elements from a ground set <cite>Z = (z_1, …)</cite> and ranking vectors
<cite>y {0, …, m - 1}^{m}</cite> with properties:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>Ranks start at zero, i.e. min(y) = 0.</p></li>
<li><p>Sorted ranks are contiguous unless one or more ties are present.</p></li>
<li><p><cite>k</cite> ranks are skipped after a <cite>k</cite>-way tie.</p></li>
</ol>
</div></blockquote>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">SliceContainer</span><span class="p">(</span>
    <span class="n">values</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">indices</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="mi">16</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]),</span>
    <span class="n">event_shape</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]),</span>
<span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">DenseContainer</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]),</span>
    <span class="n">event_shape</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="p">)</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">RankingDataset</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Construct a <cite>RankingDataset</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<a class="reference internal" href="#botorch.utils.containers.SliceContainer" title="botorch.utils.containers.SliceContainer"><em>SliceContainer</em></a>) – A <cite>SliceContainer</cite> representing the input features being ranked.</p></li>
<li><p><strong>Y</strong> (<em>BotorchContainer</em>) – A <cite>Tensor</cite> or <cite>BotorchContainer</cite> representing the rankings.</p></li>
<li><p><strong>validate_init</strong> (<em>bool</em>) – If <cite>True</cite>, validates the input shapes.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.datasets.RankingDataset.X">
<span class="sig-name descname"><span class="pre">X</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#botorch.utils.containers.SliceContainer" title="botorch.utils.containers.SliceContainer"><span class="pre">SliceContainer</span></a></em><a class="headerlink" href="#botorch.utils.datasets.RankingDataset.X" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.datasets.RankingDataset.Y">
<span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">BotorchContainer</span></em><a class="headerlink" href="#botorch.utils.datasets.RankingDataset.Y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.dispatcher">
<span id="dispatcher"></span><h2>Dispatcher<a class="headerlink" href="#module-botorch.utils.dispatcher" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.type_bypassing_encoder">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.dispatcher.</span></span><span class="sig-name descname"><span class="pre">type_bypassing_encoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#type_bypassing_encoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.type_bypassing_encoder" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>arg</strong> (<em>Any</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Type</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.dispatcher.</span></span><span class="sig-name descname"><span class="pre">Dispatcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoder=&lt;class</span> <span class="pre">'type'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Dispatcher</span></code></p>
<p>Clearing house for multiple dispatch functionality. This class extends
<cite>&lt;multipledispatch.Dispatcher&gt;</cite> by: (i) generalizing the argument encoding
convention during method lookup, (ii) implementing <cite>__getitem__</cite> as a dedicated
method lookup function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – A string identifier for the <cite>Dispatcher</cite> instance.</p></li>
<li><p><strong>doc</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A docstring for the multiply dispatched method(s).</p></li>
<li><p><strong>encoder</strong> (<em>Callable</em><em>[</em><em>Any</em><em>, </em><em>Type</em><em>]</em>) – A callable that individually transforms the arguments passed
at runtime in order to construct the key used for method lookup as
<cite>tuple(map(encoder, args))</cite>. Defaults to <cite>type</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.dispatch">
<span class="sig-name descname"><span class="pre">dispatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">types</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher.dispatch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.dispatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Method lookup strategy. Checks for an exact match before traversing
the set of registered methods according to the current ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>types</strong> (<em>Type</em>) – A tuple of types that gets compared with the signatures
of registered methods to determine compatibility.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The first method encountered with a matching signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Callable</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.encode_args">
<span class="sig-name descname"><span class="pre">encode_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher.encode_args"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.encode_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts arguments into a tuple of types used during method lookup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>args</strong> (<em>Any</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tuple</em>[<em>Type</em>]</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.help">
<span class="sig-name descname"><span class="pre">help</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher.help"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.help" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the retrieved method’s docstring.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> (<em>Any</em>) – </p></li>
<li><p><strong>kwargs</strong> (<em>Any</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher.source"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.source" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the retrieved method’s source types.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.encoder">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">encoder</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Type</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.encoder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.funcs">
<span class="sig-name descname"><span class="pre">funcs</span></span><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.funcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.doc">
<span class="sig-name descname"><span class="pre">doc</span></span><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.doc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.low_rank">
<span id="low-rank-cholesky-update-utils"></span><h2>Low-Rank Cholesky Update Utils<a class="headerlink" href="#module-botorch.utils.low_rank" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.low_rank.extract_batch_covar">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.low_rank.</span></span><span class="sig-name descname"><span class="pre">extract_batch_covar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mt_mvn</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/low_rank.html#extract_batch_covar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.low_rank.extract_batch_covar" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a batched independent covariance matrix from an MTMVN.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mt_mvn</strong> (<em>MultitaskMultivariateNormal</em>) – A multi-task multivariate normal with a block diagonal
covariance matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A lazy covariance matrix consisting of a batch of the blocks of</dt><dd><p>the diagonal of the MultitaskMultivariateNormal.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>LinearOperator</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.low_rank.sample_cached_cholesky">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.low_rank.</span></span><span class="sig-name descname"><span class="pre">sample_cached_cholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseline_L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_tries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/low_rank.html#sample_cached_cholesky"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.low_rank.sample_cached_cholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Get posterior samples at the <cite>q</cite> new points from the joint multi-output
posterior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>posterior</strong> (<a class="reference internal" href="posteriors.html#botorch.posteriors.gpytorch.GPyTorchPosterior" title="botorch.posteriors.gpytorch.GPyTorchPosterior"><em>GPyTorchPosterior</em></a>) – The joint posterior is over (X_baseline, X).</p></li>
<li><p><strong>baseline_L</strong> (<em>Tensor</em>) – The baseline lower triangular cholesky factor.</p></li>
<li><p><strong>q</strong> (<em>int</em>) – The number of new points in X.</p></li>
<li><p><strong>base_samples</strong> (<em>Tensor</em>) – The base samples.</p></li>
<li><p><strong>sample_shape</strong> (<em>Size</em>) – The sample shape.</p></li>
<li><p><strong>max_tries</strong> (<em>int</em>) – The number of tries for computing the Cholesky
decomposition with increasing jitter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>sample_shape x batch_shape x q x m</cite>-dim tensor of posterior</dt><dd><p>samples at the new points.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.objective">
<span id="objective"></span><h2>Objective<a class="headerlink" href="#module-botorch.utils.objective" title="Permalink to this heading">¶</a></h2>
<p>Helpers for handling objectives.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.get_objective_weights_transform">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">get_objective_weights_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#get_objective_weights_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.get_objective_weights_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a linear objective callable from a set of weights.</p>
<p>Create a callable mapping a Tensor of size <cite>b x q x m</cite> and an (optional)
Tensor of size <cite>b x q x d</cite> to a Tensor of size <cite>b x q</cite>, where <cite>m</cite> is the
number of outputs of the model using scalarization via the objective weights.
This callable supports broadcasting (e.g. for calling on a tensor of shape
<cite>mc_samples x b x q x m</cite>). For <cite>m = 1</cite>, the objective weight is used to
determine the optimization direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>Tensor</em><em> | </em><em>None</em>) – a 1-dimensional Tensor containing a weight for each task.
If not provided, the identity mapping is used.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transform function using the objective weights.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Callable</em>[[<em>Tensor</em>, <em>Tensor</em> | None], <em>Tensor</em>]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span> <span class="o">=</span> <span class="n">get_objective_weights_transform</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.apply_constraints_nonnegative_soft">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">apply_constraints_nonnegative_soft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#apply_constraints_nonnegative_soft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.apply_constraints_nonnegative_soft" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies constraints to a non-negative objective.</p>
<p>This function uses a sigmoid approximation to an indicator function for
each constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q (x m’)</cite>-dim Tensor of objective values.</p></li>
<li><p><strong>constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of size <cite>b x q x m</cite>
to a Tensor of size <cite>b x q</cite>, where negative values imply feasibility.
This callable must support broadcasting. Only relevant for multi-
output models (<cite>m</cite> &gt; 1).</p></li>
<li><p><strong>samples</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q x m</cite> Tensor of samples drawn from the posterior.</p></li>
<li><p><strong>eta</strong> (<em>Tensor</em><em> | </em><em>float</em>) – The temperature parameter for the sigmoid function. Can be either a float
or a 1-dim tensor. In case of a float the same eta is used for every
constraint in constraints. In case of a tensor the length of the tensor
must match the number of provided constraints. The i-th constraint is
then estimated with the i-th eta value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n_samples x b x q (x m’)</cite>-dim tensor of feasibility-weighted objectives.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.compute_feasibility_indicator">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">compute_feasibility_indicator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#compute_feasibility_indicator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.compute_feasibility_indicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the feasibility of a list of constraints given posterior samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>] </em><em>| </em><em>None</em>) – A list of callables, each mapping a batch_shape x q x m`-dim Tensor
to a <cite>batch_shape x q</cite>-dim Tensor, where negative values imply feasibility.</p></li>
<li><p><strong>samples</strong> (<em>Tensor</em>) – A batch_shape x q x m`-dim Tensor of posterior samples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape x q</cite>-dim tensor of Boolean feasibility values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.compute_smoothed_feasibility_indicator">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">compute_smoothed_feasibility_indicator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#compute_smoothed_feasibility_indicator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.compute_smoothed_feasibility_indicator" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the smoothed feasibility indicator of a list of constraints.</p>
<p>Given posterior samples, using a sigmoid to smoothly approximate the feasibility
indicator of each individual constraint to ensure differentiability and high
gradient signal. The <cite>fat</cite> and <cite>log</cite> options improve the numerical behavior of
the smooth approximation.</p>
<p>NOTE: <em>Negative</em> constraint values are associated with feasibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of size <cite>b x q x m</cite>
to a Tensor of size <cite>b x q</cite>, where negative values imply feasibility.
This callable must support broadcasting. Only relevant for multi-
output models (<cite>m</cite> &gt; 1).</p></li>
<li><p><strong>samples</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q x m</cite> Tensor of samples drawn from the posterior.</p></li>
<li><p><strong>eta</strong> (<em>Tensor</em><em> | </em><em>float</em>) – The temperature parameter for the sigmoid function. Can be either a float
or a 1-dim tensor. In case of a float the same eta is used for every
constraint in constraints. In case of a tensor the length of the tensor
must match the number of provided constraints. The i-th constraint is
then estimated with the i-th eta value.</p></li>
<li><p><strong>log</strong> (<em>bool</em>) – Toggles the computation of the log-feasibility indicator.</p></li>
<li><p><strong>fat</strong> (<em>bool</em>) – Toggles the computation of the fat-tailed feasibility indicator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n_samples x b x q</cite>-dim tensor of feasibility indicator values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.soft_eval_constraint">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">soft_eval_constraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#soft_eval_constraint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.soft_eval_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise evaluation of a constraint in a ‘soft’ fashion</p>
<p><cite>value(x) = 1 / (1 + exp(x / eta))</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lhs</strong> (<em>Tensor</em>) – The left hand side of the constraint <cite>lhs &lt;= 0</cite>.</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – The temperature parameter of the softmax function. As eta
decreases, this approximates the Heaviside step function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Element-wise ‘soft’ feasibility indicator of the same shape as <cite>lhs</cite>.
For each element <cite>x</cite>, <cite>value(x) -&gt; 0</cite> as <cite>x</cite> becomes positive, and
<cite>value(x) -&gt; 1</cite> as x becomes negative.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.apply_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">apply_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infeasible_cost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#apply_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.apply_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply constraints using an infeasible_cost <cite>M</cite> for negative objectives.</p>
<p>This allows feasibility-weighting an objective for the case where the
objective can be negative by using the following strategy:
(1) Add <cite>M</cite> to make obj non-negative;
(2) Apply constraints using the sigmoid approximation;
(3) Shift by <cite>-M</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q (x m’)</cite>-dim Tensor of objective values.</p></li>
<li><p><strong>constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of size <cite>b x q x m</cite>
to a Tensor of size <cite>b x q</cite>, where negative values imply feasibility.
This callable must support broadcasting. Only relevant for multi-
output models (<cite>m</cite> &gt; 1).</p></li>
<li><p><strong>samples</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q x m</cite> Tensor of samples drawn from the posterior.</p></li>
<li><p><strong>infeasible_cost</strong> (<em>float</em>) – The infeasible value.</p></li>
<li><p><strong>eta</strong> (<em>Tensor</em><em> | </em><em>float</em>) – The temperature parameter of the sigmoid function. Can be either a float
or a 1-dim tensor. In case of a float the same eta is used for every
constraint in constraints. In case of a tensor the length of the tensor
must match the number of provided constraints. The i-th constraint is
then estimated with the i-th eta value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n_samples x b x q (x m’)</cite>-dim tensor of feasibility-weighted objectives.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.rounding">
<span id="rounding"></span><h2>Rounding<a class="headerlink" href="#module-botorch.utils.rounding" title="Permalink to this heading">¶</a></h2>
<p>Discretization (rounding) functions for acquisition optimization.</p>
<p>References</p>
<div class="citation-list" role="list">
<div class="citation" id="daulton2022bopr" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Daulton2022bopr<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a href="#id1" role="doc-backlink">1</a>,<a href="#id2" role="doc-backlink">2</a>)</span>
<p>S. Daulton, X. Wan, D. Eriksson, M. Balandat, M. A. Osborne, E. Bakshy.
Bayesian Optimization over Discrete and Mixed Spaces via Probabilistic
Reparameterization. Advances in Neural Information Processing Systems
35, 2022.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.rounding.approximate_round">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.rounding.</span></span><span class="sig-name descname"><span class="pre">approximate_round</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#approximate_round"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.approximate_round" title="Permalink to this definition">¶</a></dt>
<dd><p>Diffentiable approximate rounding function.</p>
<p>This method is a piecewise approximation of a rounding function where
each piece is a hyperbolic tangent function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – The tensor to round to the nearest integer (element-wise).</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – A temperature hyperparameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximately rounded input tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.rounding.IdentitySTEFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.rounding.</span></span><span class="sig-name descname"><span class="pre">IdentitySTEFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#IdentitySTEFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.IdentitySTEFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></p>
<p>Base class for functions using straight through gradient estimators.</p>
<p>This class approximates the gradient with the identity function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.rounding.IdentitySTEFunction.backward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#IdentitySTEFunction.backward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.IdentitySTEFunction.backward" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a straight-through estimator the gradient.</p>
<p>This uses the identity function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>grad_output</strong> (<em>Tensor</em>) – A tensor of gradients.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The provided tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.rounding.RoundSTE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.rounding.</span></span><span class="sig-name descname"><span class="pre">RoundSTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#RoundSTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.RoundSTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.rounding.IdentitySTEFunction" title="botorch.utils.rounding.IdentitySTEFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">IdentitySTEFunction</span></code></a></p>
<p>Round the input tensor and use a straight-through gradient estimator.</p>
<p><a class="reference internal" href="#daulton2022bopr" id="id1"><span>[Daulton2022bopr]</span></a> proposes using this in acquisition optimization.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.rounding.RoundSTE.forward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#RoundSTE.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.RoundSTE.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Round the input tensor element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>) – The tensor to be rounded.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor where each element is rounded to the nearest integer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.rounding.OneHotArgmaxSTE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.rounding.</span></span><span class="sig-name descname"><span class="pre">OneHotArgmaxSTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#OneHotArgmaxSTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.OneHotArgmaxSTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.rounding.IdentitySTEFunction" title="botorch.utils.rounding.IdentitySTEFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">IdentitySTEFunction</span></code></a></p>
<p>Discretize a continuous relaxation of a one-hot encoded categorical.</p>
<p>This returns a one-hot encoded categorical and use a straight-through
gradient estimator via an identity function.</p>
<p><a class="reference internal" href="#daulton2022bopr" id="id2"><span>[Daulton2022bopr]</span></a> proposes using this in acquisition optimization.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.rounding.OneHotArgmaxSTE.forward">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#OneHotArgmaxSTE.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.OneHotArgmaxSTE.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretize the input tensor.</p>
<p>This applies a argmax along the last dimensions of the input tensor
and one-hot encodes the result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>) – The tensor to be rounded.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor where each element is rounded to the nearest integer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.sampling">
<span id="sampling"></span><h2>Sampling<a class="headerlink" href="#module-botorch.utils.sampling" title="Permalink to this heading">¶</a></h2>
<p>Utilities for MC and qMC sampling.</p>
<p>References</p>
<div class="citation-list" role="list">
<div class="citation" id="trikalinos2014polytope" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a href="#id3" role="doc-backlink">Trikalinos2014polytope</a><span class="fn-bracket">]</span></span>
<p>T. A. Trikalinos and G. van Valkenhoef. Efficient sampling from uniform
density n-polytopes. Technical report, Brown University, 2014.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.manual_seed">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">manual_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#manual_seed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.manual_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Contextmanager for manual setting the torch.random seed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed to set the random number generator to.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generator</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Generator</em>[None, None, None]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">manual_seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.draw_sobol_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">draw_sobol_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#draw_sobol_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.draw_sobol_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw qMC samples from the box defined by bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite> dimensional tensor specifying box constraints on a
<cite>d</cite>-dimensional space, where bounds[0, :] and bounds[1, :] correspond
to lower and upper bounds, respectively.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of (q-batch) samples. As a best practice, use powers of 2.</p></li>
<li><p><strong>q</strong> (<em>int</em>) – The size of each q-batch.</p></li>
<li><p><strong>batch_shape</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><em>int</em><em>]</em><em>, </em><em>torch.Size</em><em>]</em>) – The batch shape of the samples. If given, returns samples
of shape <cite>n x batch_shape x q x d</cite>, where each batch is an
<cite>n x q x d</cite>-dim tensor of qMC samples.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The seed used for initializing Owen scrambling. If None (default),
use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x batch_shape x q x d</cite>-dim tensor of qMC samples from the box
defined by bounds.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">draw_sobol_samples</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.draw_sobol_normal_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">draw_sobol_normal_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#draw_sobol_normal_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.draw_sobol_normal_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw qMC samples from a multi-variate standard normal N(0, I_d).</p>
<p>A primary use-case for this functionality is to compute an QMC average
of f(X) over X where each element of X is drawn N(0, 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the normal distribution.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of samples to return. As a best practice, use powers of 2.</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – The torch device.</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – The torch dtype.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed used for initializing Owen scrambling. If None (default),
use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of qMC standard normal samples with dimension <cite>n x d</cite> with device
and dtype specified by the input.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">draw_sobol_normal_samples</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_hypersphere">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_hypersphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_hypersphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_hypersphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample uniformly from a unit d-sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the hypersphere.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of samples to return.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – If True, use QMC Sobol sampling (instead of i.i.d. uniform).</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – If provided, use as a seed for the RNG.</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – The torch device.</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – The torch dtype.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An  <cite>n x d</cite> tensor of uniform samples from from the d-hypersphere.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_hypersphere</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_simplex">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_simplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_simplex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_simplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample uniformly from a d-simplex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the simplex.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of samples to return.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – If True, use QMC Sobol sampling (instead of i.i.d. uniform).</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – If provided, use as a seed for the RNG.</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – The torch device.</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – The torch dtype.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An <cite>n x d</cite> tensor of uniform samples from from the d-simplex.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_simplex</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_polytope">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_polytope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Hit and run sampler from uniform sampling points from a polytope,
described via inequality constraints A*x&lt;=b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>Tensor</em>) – A Tensor describing inequality constraints
so that all samples satisfy Ax&lt;=b.</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – A Tensor describing the inequality constraints
so that all samples satisfy Ax&lt;=b.</p></li>
<li><p><strong>x0</strong> (<em>Tensor</em>) – A <cite>d</cite>-dim Tensor representing a starting point of the chain
satisfying the constraints.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of resulting samples kept in the output.</p></li>
<li><p><strong>n0</strong> (<em>int</em>) – The number of burn-in samples. The chain will produce
n+n0 samples but the first n0 samples are not saved.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed for the sampler. If omitted, use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(n, d) dim Tensor containing the resulting samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.batched_multinomial">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">batched_multinomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#batched_multinomial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.batched_multinomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from multinomial with an arbitrary number of batch dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>Tensor</em>) – A <cite>batch_shape x num_categories</cite> tensor of weights. For each batch
index <cite>i, j, …</cite>, this functions samples from a multinomial with <cite>input</cite>
<cite>weights[i, j, …, :]</cite>. Note that the weights need not sum to one, but must
be non-negative, finite and have a non-zero sum.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to draw for each batch index. Must be smaller
than <cite>num_categories</cite> if <cite>replacement=False</cite>.</p></li>
<li><p><strong>replacement</strong> (<em>bool</em>) – If True, samples are drawn with replacement.</p></li>
<li><p><strong>generator</strong> (<em>Generator</em><em> | </em><em>None</em>) – A a pseudorandom number generator for sampling.</p></li>
<li><p><strong>out</strong> (<em>Tensor</em><em> | </em><em>None</em>) – The output tensor (optional). If provided, must be of size
<cite>batch_shape x num_samples</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape x num_samples</cite> tensor of samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>LongTensor</em></p>
</dd>
</dl>
<p>This is a thin wrapper around <cite>torch.multinomial</cite> that allows weight (<cite>input</cite>)
tensors with an arbitrary number of batch dimensions (<cite>torch.multinomial</cite> only
allows a single batch dimension). The calling signature is the same as for
<cite>torch.multinomial</cite>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">batched_multinomial</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># shape is 2 x 3 x 4</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.find_interior_point">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">find_interior_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A_eq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_eq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#find_interior_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.find_interior_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an interior point of a polytope via linear programming.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>ndarray</em>) – A <cite>n_ineq x d</cite>-dim numpy array containing the coefficients of the
constraint inequalities.</p></li>
<li><p><strong>b</strong> (<em>ndarray</em>) – A <cite>n_ineq x 1</cite>-dim numpy array containing the right hand sides of
the constraint inequalities.</p></li>
<li><p><strong>A_eq</strong> (<em>ndarray</em><em> | </em><em>None</em>) – A <cite>n_eq x d</cite>-dim numpy array containing the coefficients of the
constraint equalities.</p></li>
<li><p><strong>b_eq</strong> (<em>ndarray</em><em> | </em><em>None</em>) – A <cite>n_eq x 1</cite>-dim numpy array containing the right hand sides of
the constraint equalities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>d</cite>-dim numpy array containing an interior point of the polytope.
This function will raise a ValueError if there is no such point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em></p>
</dd>
</dl>
<p>This method solves the following Linear Program:</p>
<blockquote>
<div><p>min -s subject to A @ x &lt;= b - 2 * s, s &gt;= 0, A_eq @ x = b_eq</p>
</div></blockquote>
<p>In case the polytope is unbounded, then it will also constrain the slack
variable <cite>s</cite> to <cite>s&lt;=1</cite>.</p>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.sampling.HitAndRunPolytopeSampler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">HitAndRunPolytopeSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#HitAndRunPolytopeSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.HitAndRunPolytopeSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">PolytopeSampler</span></code></p>
<p>A sampler for sampling from a polyope using a hit-and-run algorithm.</p>
<p>A sampler for sampling from a polyope using a hit-and-run algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(A, b)</cite> describing inequality
constraints <cite>A @ x &lt;= b</cite>, where <cite>A</cite> is a <cite>n_ineq_con x d</cite>-dim
Tensor and <cite>b</cite> is a <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite>
the number of inequalities and <cite>d</cite> the dimension of the sample space.</p></li>
<li><p><strong>equality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(C, d)</cite> describing the equality constraints
<cite>C @ x = d</cite>, where <cite>C</cite> is a <cite>n_eq_con x d</cite>-dim Tensor and <cite>d</cite> is a
<cite>n_eq_con x 1</cite>-dim Tensor with <cite>n_eq_con</cite> the number of equalities.</p></li>
<li><p><strong>bounds</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>2 x d</cite>-dim tensor of box bounds, where <cite>inf</cite> (<cite>-inf</cite>) means
that the respective dimension is unbounded from above (below).</p></li>
<li><p><strong>interior_point</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>d x 1</cite>-dim Tensor representing a point in the
(relative) interior of the polytope. If omitted, determined
automatically by solving a Linear Program.</p></li>
<li><p><strong>n_burnin</strong> (<em>int</em>) – The number of burn in samples.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.HitAndRunPolytopeSampler.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#HitAndRunPolytopeSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.HitAndRunPolytopeSampler.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw samples from the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x d</cite> Tensor of samples from the polytope.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.sampling.DelaunayPolytopeSampler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">DelaunayPolytopeSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#DelaunayPolytopeSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.DelaunayPolytopeSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">PolytopeSampler</span></code></p>
<p>A polytope sampler using Delaunay triangulation.</p>
<p>This sampler first enumerates the vertices of the constraint polytope and
then uses a Delaunay triangulation to tesselate its convex hull.</p>
<p>The sampling happens in two stages:
1. First, we sample from the set of hypertriangles generated by the
Delaunay triangulation (i.e. which hyper-triangle to draw the sample
from) with probabilities proportional to the triangle volumes.
2. Then, we sample uniformly from the chosen hypertriangle by sampling
uniformly from the unit simplex of the appropriate dimension, and
then computing the convex combination of the vertices of the
hypertriangle according to that draw from the simplex.</p>
<p>The best reference (not exactly the same, but functionally equivalent) is
<a class="reference internal" href="#trikalinos2014polytope" id="id3"><span>[Trikalinos2014polytope]</span></a>. A simple R implementation is available at
<a class="reference external" href="https://github.com/gertvv/tesselample">https://github.com/gertvv/tesselample</a>.</p>
<p>Initialize DelaunayPolytopeSampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(A, b)</cite> describing inequality
constraints <cite>A @ x &lt;= b</cite>, where <cite>A</cite> is a <cite>n_ineq_con x d</cite>-dim
Tensor and <cite>b</cite> is a <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite>
the number of inequalities and <cite>d</cite> the dimension of the sample space.</p></li>
<li><p><strong>equality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(C, d)</cite> describing the equality constraints
<cite>C @ x = d</cite>, where <cite>C</cite> is a <cite>n_eq_con x d</cite>-dim Tensor and <cite>d</cite> is a
<cite>n_eq_con x 1</cite>-dim Tensor with <cite>n_eq_con</cite> the number of equalities.</p></li>
<li><p><strong>bounds</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>2 x d</cite>-dim tensor of box bounds, where <cite>inf</cite> (<cite>-inf</cite>) means
that the respective dimension is unbounded from above (below).</p></li>
<li><p><strong>interior_point</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>d x 1</cite>-dim Tensor representing a point in the
(relative) interior of the polytope. If omitted, determined
automatically by solving a Linear Program.</p></li>
</ul>
</dd>
</dl>
<p>Warning: The vertex enumeration performed in this algorithm can become
extremely costly if there are a large number of inequalities. Similarly,
the triangulation can get very expensive in high dimensions. Only use
this algorithm for moderate dimensions / moderately complex constraint sets.
An alternative is the <cite>HitAndRunPolytopeSampler</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.DelaunayPolytopeSampler.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#DelaunayPolytopeSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.DelaunayPolytopeSampler.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw samples from the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x d</cite> Tensor of samples from the polytope.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.normalize_linear_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">normalize_linear_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#normalize_linear_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.normalize_linear_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize linear constraints to the unit cube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite>-dim tensor containing the box bounds.</p></li>
<li><p><strong>constraints</strong> (<em>List</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>]</em>) – A list of
tuples (indices, coefficients, rhs), with each tuple encoding
an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite> or
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>List</em>[<em>Tuple</em>[<em>Tensor</em>, <em>Tensor</em>, float]]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.get_polytope_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">get_polytope_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thinning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#get_polytope_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.get_polytope_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from polytope defined by box bounds and (in)equality constraints.</p>
<p>This uses a hit-and-run Markov chain sampler.</p>
<p>TODO: make this method return the sampler object, to avoid doing burn-in
every time we draw samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of samples.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite>-dim tensor containing the box bounds.</p></li>
<li><p><strong>constraints</strong> (<em>equality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>constraints</strong> – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The random seed.</p></li>
<li><p><strong>thinning</strong> (<em>int</em>) – The amount of thinning.</p></li>
<li><p><strong>n_burnin</strong> (<em>int</em>) – The number of burn-in samples for the Markov chain sampler.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>List</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
<li><p><strong>equality_constraints</strong> (<em>List</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x d</cite>-dim tensor of samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sparse_to_dense_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sparse_to_dense_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sparse_to_dense_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sparse_to_dense_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert parameter constraints from a sparse format into a dense format.</p>
<p>This method converts sparse triples of the form (indices, coefficients, rhs)
to constraints of the form Ax &gt;= b or Ax = b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The input dimension.</p></li>
<li><p><strong>constraints</strong> (<em>inequality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an (in)equality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite> or
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A: A <cite>n_constraints x d</cite>-dim tensor of coefficients.</p></li>
<li><p>b: A <cite>n_constraints x 1</cite>-dim tensor of right hand sides.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A two-element tuple containing</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.optimize_posterior_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">optimize_posterior_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">paths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">candidates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_restarts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#optimize_posterior_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.optimize_posterior_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Cheaply maximizes posterior samples by random querying followed by vanilla
gradient descent on the best num_restarts points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>paths</strong> (<a class="reference internal" href="sampling.html#botorch.sampling.pathwise.paths.SamplePath" title="botorch.sampling.pathwise.paths.SamplePath"><em>SamplePath</em></a>) – Random Fourier Feature-based sample paths from the GP</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – The bounds on the search space.</p></li>
<li><p><strong>candidates</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A priori good candidates (typically previous design points)
which acts as extra initial guesses for the optimization routine.</p></li>
<li><p><strong>raw_samples</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The number of samples with which to query the samples initially.</p></li>
<li><p><strong>num_restarts</strong> (<em>int</em>) – The number of points selected for gradient-based optimization.</p></li>
<li><p><strong>maximize</strong> (<em>bool</em>) – Boolean indicating whether to maimize or minimize</p></li>
<li><p><strong>kwargs</strong> (<em>Any</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>X_opt: A <cite>num_optima x [batch_size] x d</cite>-dim tensor of optimal inputs x*.</p></li>
<li><p>f_opt: A <cite>num_optima x [batch_size] x 1</cite>-dim tensor of optimal outputs f*.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A two-element tuple containing</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.gp_sampling">
<span id="sampling-from-gp-priors"></span><h2>Sampling from GP priors<a class="headerlink" href="#module-botorch.utils.gp_sampling" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">GPDraw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#GPDraw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Convenience wrapper for sampling a function from a GP prior.</p>
<p>This wrapper implicitly defines the GP sample as a self-updating function by keeping
track of the evaluated points and respective base samples used during the
evaluation.</p>
<p>This does not yet support multi-output models.</p>
<p>Construct a GP function sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – The Model defining the GP prior.</p></li>
<li><p><strong>seed</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw.Xs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Xs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw.Xs" title="Permalink to this definition">¶</a></dt>
<dd><p>A <cite>(batch_shape) x n_eval x d</cite>-dim tensor of locations at which the GP was
evaluated (or <cite>None</cite> if the sample has never been evaluated).</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw.Ys">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Ys</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw.Ys" title="Permalink to this definition">¶</a></dt>
<dd><p>A <cite>(batch_shape) x n_eval x d</cite>-dim tensor of associated function values (or
<cite>None</cite> if the sample has never been evaluated).</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#GPDraw.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the GP sample function at a set of points X.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>) – A <cite>batch_shape x n x d</cite>-dim tensor of points</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The value of the GP sample at the <cite>n</cite> points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.GPDraw.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.gp_sampling.GPDraw.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.RandomFourierFeatures">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">RandomFourierFeatures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_rff_features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#RandomFourierFeatures"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.RandomFourierFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>A class that represents Random Fourier Features.</p>
<p>Initialize RandomFourierFeatures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel</strong> (<em>Kernel</em>) – The GP kernel.</p></li>
<li><p><strong>input_dim</strong> (<em>int</em>) – The input dimension to the GP kernel.</p></li>
<li><p><strong>num_rff_features</strong> (<em>int</em>) – The number of Fourier features.</p></li>
<li><p><strong>sample_shape</strong> (<em>Optional</em><em>[</em><em>torch.Size</em><em>]</em>) – The shape of a single sample. For a single-element
<cite>torch.Size</cite> object, this is simply the number of RFF draws.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.RandomFourierFeatures.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#RandomFourierFeatures.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.RandomFourierFeatures.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Fourier basis features for the provided inputs.</p>
<p>Note that the right-most subset of the batch shape of <cite>X</cite> should
be <cite>(sample_shape) x (kernel_batch_shape)</cite> if using either the
<cite>sample_shape</cite> argument or a batched kernel. In other words,
<cite>X</cite> should be of shape <cite>(added_batch_shape) x (sample_shape) x
(kernel_batch_shape) x n x input_dim</cite>, where parantheses denote
that the given batch shape can be empty. <cite>X</cite> can always be
a tensor of shape <cite>n x input_dim</cite>, in which case broadcasting
will take care of the batch shape. This will raise a <cite>ValueError</cite>
if the batch shapes are not compatible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>) – Input tensor of shape <cite>(batch_shape) x n x input_dim</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of shape <cite>(batch_shape) x n x rff</cite>. If <cite>X</cite> does not have
a <cite>batch_shape</cite>, the output <cite>batch_shape</cite> will be
<cite>(sample_shape) x (kernel_batch_shape)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.RandomFourierFeatures.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.gp_sampling.RandomFourierFeatures.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.get_deterministic_model_multi_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">get_deterministic_model_multi_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#get_deterministic_model_multi_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.get_deterministic_model_multi_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a batched deterministic model that batch evaluates <cite>n_samples</cite> function
samples. This supports multi-output models as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>List</em><em>[</em><em>Tensor</em><em>]</em>) – A list of weights with <cite>num_outputs</cite> elements. Each weight is of
shape <cite>(batch_shape_input) x n_samples x num_rff_features</cite>, where
<cite>(batch_shape_input)</cite> is the batch shape of the inputs used to obtain the
posterior weights.</p></li>
<li><p><strong>bases</strong> (<em>List</em><em>[</em><a class="reference internal" href="#botorch.utils.gp_sampling.RandomFourierFeatures" title="botorch.utils.gp_sampling.RandomFourierFeatures"><em>RandomFourierFeatures</em></a><em>]</em>) – A list of <cite>RandomFourierFeatures</cite> with <cite>num_outputs</cite> elements. Each
basis has a sample shape of <cite>n_samples</cite>.</p></li>
<li><p><strong>n_samples</strong> – The number of function samples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A batched <cite>GenericDeterministicModel`s that batch evaluates `n_samples</cite>
function samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="models.html#botorch.models.deterministic.GenericDeterministicModel" title="botorch.models.deterministic.GenericDeterministicModel"><em>GenericDeterministicModel</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.get_eval_gp_sample_callable">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">get_eval_gp_sample_callable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#get_eval_gp_sample_callable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.get_eval_gp_sample_callable" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>basis</strong> (<a class="reference internal" href="#botorch.utils.gp_sampling.RandomFourierFeatures" title="botorch.utils.gp_sampling.RandomFourierFeatures"><em>RandomFourierFeatures</em></a>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.get_deterministic_model">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">get_deterministic_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#get_deterministic_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.get_deterministic_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a deterministic model using the provided weights and bases for each output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>List</em><em>[</em><em>Tensor</em><em>]</em>) – A list of weights with <cite>m</cite> elements.</p></li>
<li><p><strong>bases</strong> (<em>List</em><em>[</em><a class="reference internal" href="#botorch.utils.gp_sampling.RandomFourierFeatures" title="botorch.utils.gp_sampling.RandomFourierFeatures"><em>RandomFourierFeatures</em></a><em>]</em>) – A list of <cite>RandomFourierFeatures</cite> with <cite>m</cite> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A deterministic model.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="models.html#botorch.models.deterministic.GenericDeterministicModel" title="botorch.models.deterministic.GenericDeterministicModel"><em>GenericDeterministicModel</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.get_deterministic_model_list">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">get_deterministic_model_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#get_deterministic_model_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.get_deterministic_model_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a deterministic model list using the provided weights and bases
for each output.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>List</em><em>[</em><em>Tensor</em><em>]</em>) – A list of weights with <cite>m</cite> elements.</p></li>
<li><p><strong>bases</strong> (<em>List</em><em>[</em><a class="reference internal" href="#botorch.utils.gp_sampling.RandomFourierFeatures" title="botorch.utils.gp_sampling.RandomFourierFeatures"><em>RandomFourierFeatures</em></a><em>]</em>) – A list of <cite>RandomFourierFeatures</cite> with <cite>m</cite> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A deterministic model.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="models.html#botorch.models.model.ModelList" title="botorch.models.model.ModelList"><em>ModelList</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.get_weights_posterior">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">get_weights_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_sq</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#get_weights_posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.get_weights_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample bayesian linear regression weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A tensor of inputs with shape <cite>(*batch_shape, n num_rff_features)</cite>.</p></li>
<li><p><strong>y</strong> (<em>Tensor</em>) – A tensor of outcomes with shape <cite>(*batch_shape, n)</cite>.</p></li>
<li><p><strong>sigma_sq</strong> (<em>Tensor</em>) – The likelihood noise variance. This should be a tensor with
shape <cite>kernel_batch_shape, 1, 1</cite> if using a batched kernel.
Otherwise, it should be a scalar tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The posterior distribution over the weights.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>MultivariateNormal</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.gp_sampling.get_gp_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.gp_sampling.</span></span><span class="sig-name descname"><span class="pre">get_gp_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_outputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_rff_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/gp_sampling.html#get_gp_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.gp_sampling.get_gp_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample functions from GP posterior using RFFs. The returned
<cite>GenericDeterministicModel</cite> effectively wraps <cite>num_outputs</cite> models,
each of which has a batch shape of <cite>n_samples</cite>. Refer
<cite>get_deterministic_model_multi_samples</cite> for more details.</p>
<p>NOTE: If using input / outcome transforms, the gp samples must be accessed via
the <cite>gp_sample.posterior(X)</cite> call. Otherwise, <cite>gp_sample(X)</cite> will produce bogus
values that do not agree with the underlying <cite>model</cite>. It is also highly recommended
to use outcome transforms to standardize the input data, since the gp samples do
not work well when training outcomes are not zero-mean.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – The model.</p></li>
<li><p><strong>num_outputs</strong> (<em>int</em>) – The number of outputs.</p></li>
<li><p><strong>n_samples</strong> (<em>int</em>) – The number of functions to be sampled IID.</p></li>
<li><p><strong>num_rff_features</strong> (<em>int</em>) – The number of random Fourier features.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>GenericDeterministicModel</cite> that evaluates <cite>n_samples</cite> sampled functions.
If <cite>n_samples &gt; 1</cite>, this will be a batched model.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="models.html#botorch.models.deterministic.GenericDeterministicModel" title="botorch.models.deterministic.GenericDeterministicModel"><em>GenericDeterministicModel</em></a></p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.testing">
<span id="testing"></span><h2>Testing<a class="headerlink" href="#module-botorch.utils.testing" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">BotorchTestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BotorchTestCase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></p>
<p>Basic test case for Botorch.</p>
<dl class="simple">
<dt>This</dt><dd><ol class="arabic simple">
<li><p>sets the default device to be <cite>torch.device(“cpu”)</cite></p></li>
<li><p>ensures that no warnings are suppressed by default.</p></li>
</ol>
</dd>
</dl>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase.device">
<span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">device(type='cpu')</span></em><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase.device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase.setUp">
<span class="sig-name descname"><span class="pre">setUp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suppress_input_warnings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BotorchTestCase.setUp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase.setUp" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for setting up the test fixture before exercising it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>suppress_input_warnings</strong> (<em>bool</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase.assertAllClose">
<span class="sig-name descname"><span class="pre">assertAllClose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BotorchTestCase.assertAllClose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase.assertAllClose" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls torch.testing.assert_close, using the signature and default behavior
of torch.allclose.</p>
<dl>
<dt>Example output:</dt><dd><p>AssertionError: Scalars are not close!</p>
<p>Absolute difference: 1.0000034868717194 (up to 0.0001 allowed)
Relative difference: 0.8348668001940709 (up to 1e-05 allowed)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>other</strong> (<em>Tensor</em><em> | </em><em>float</em>) – </p></li>
<li><p><strong>rtol</strong> (<em>float</em>) – </p></li>
<li><p><strong>atol</strong> (<em>float</em>) – </p></li>
<li><p><strong>equal_nan</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.BaseTestProblemTestCaseMixIn">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">BaseTestProblemTestCaseMixIn</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#BaseTestProblemTestCaseMixIn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BaseTestProblemTestCaseMixIn" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.BaseTestProblemTestCaseMixIn.test_forward">
<span class="sig-name descname"><span class="pre">test_forward</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BaseTestProblemTestCaseMixIn.test_forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BaseTestProblemTestCaseMixIn.test_forward" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.BaseTestProblemTestCaseMixIn.functions">
<em class="property"><span class="pre">abstract</span><span class="w"> </span><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">functions</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="test_functions.html#botorch.test_functions.base.BaseTestProblem" title="botorch.test_functions.base.BaseTestProblem"><span class="pre">BaseTestProblem</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.BaseTestProblemTestCaseMixIn.functions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionTestCaseMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">SyntheticTestFunctionTestCaseMixin</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#SyntheticTestFunctionTestCaseMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimal_value">
<span class="sig-name descname"><span class="pre">test_optimal_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#SyntheticTestFunctionTestCaseMixin.test_optimal_value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimal_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimizer">
<span class="sig-name descname"><span class="pre">test_optimizer</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#SyntheticTestFunctionTestCaseMixin.test_optimizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimizer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MultiObjectiveTestProblemTestCaseMixin</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemTestCaseMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_attributes">
<span class="sig-name descname"><span class="pre">test_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemTestCaseMixin.test_attributes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_attributes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_max_hv">
<span class="sig-name descname"><span class="pre">test_max_hv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemTestCaseMixin.test_max_hv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_max_hv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_ref_point">
<span class="sig-name descname"><span class="pre">test_ref_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemTestCaseMixin.test_ref_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_ref_point" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedTestProblemTestCaseMixin">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">ConstrainedTestProblemTestCaseMixin</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#ConstrainedTestProblemTestCaseMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_num_constraints">
<span class="sig-name descname"><span class="pre">test_num_constraints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#ConstrainedTestProblemTestCaseMixin.test_num_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_num_constraints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_evaluate_slack_true">
<span class="sig-name descname"><span class="pre">test_evaluate_slack_true</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#ConstrainedTestProblemTestCaseMixin.test_evaluate_slack_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_evaluate_slack_true" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MockPosterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockPosterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockPosterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></p>
<p>Mock object that implements dummy methods and feeds through specified outputs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mean</strong> – The mean of the posterior.</p></li>
<li><p><strong>variance</strong> – The variance of the posterior.</p></li>
<li><p><strong>samples</strong> – Samples to return from <cite>rsample</cite>, unless <cite>base_samples</cite> is
provided.</p></li>
<li><p><strong>base_shape</strong> – If given, this is returned as <cite>base_sample_shape</cite>, and also
used as the base of the <cite>_extended_shape</cite>.</p></li>
<li><p><strong>batch_range</strong> – If given, this is returned as <cite>batch_range</cite>.
Defaults to (0, -2).</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.device">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">device</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.device" title="Permalink to this definition">¶</a></dt>
<dd><p>The torch device of the distribution.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The torch dtype of the distribution.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.batch_shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">batch_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.batch_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.base_sample_shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">base_sample_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.base_sample_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The base shape of the base samples expected in <cite>rsample</cite>.</p>
<p>Informs the sampler to produce base samples of shape
<cite>sample_shape x base_sample_shape</cite>.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.batch_range">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">batch_range</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.batch_range" title="Permalink to this definition">¶</a></dt>
<dd><p>The t-batch range.</p>
<p>This is used in samplers to identify the t-batch component of the
<cite>base_sample_shape</cite>. The base samples are expanded over the t-batches to
provide consistency in the acquisition values, i.e., to ensure that a
candidate produces same value regardless of its position on the t-batch.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.mean">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mean</span></span><a class="headerlink" href="#botorch.utils.testing.MockPosterior.mean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.variance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">variance</span></span><a class="headerlink" href="#botorch.utils.testing.MockPosterior.variance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockPosterior.rsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockPosterior.rsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Mock sample by repeating self._samples. If base_samples is provided,
do a shape check but return the same mock samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_shape</strong> (<em>Size</em><em> | </em><em>None</em>) – </p></li>
<li><p><strong>base_samples</strong> (<em>Tensor</em><em> | </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.rsample_from_base_samples">
<span class="sig-name descname"><span class="pre">rsample_from_base_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_samples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockPosterior.rsample_from_base_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockPosterior.rsample_from_base_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from the posterior (with gradients) using base samples.</p>
<p>This is intended to be used with a sampler that produces the corresponding base
samples, and enables acquisition optimization via Sample Average Approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_shape</strong> (<em>Size</em>) – A <cite>torch.Size</cite> object specifying the sample shape. To
draw <cite>n</cite> samples, set to <cite>torch.Size([n])</cite>. To draw <cite>b</cite> batches
of <cite>n</cite> samples each, set to <cite>torch.Size([b, n])</cite>.</p></li>
<li><p><strong>base_samples</strong> (<em>Tensor</em>) – The base samples, obtained from the appropriate sampler.
This is a tensor of shape <cite>sample_shape x base_sample_shape</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Samples from the posterior, a tensor of shape
<cite>self._extended_shape(sample_shape=sample_shape)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MockModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>, <a class="reference internal" href="models.html#botorch.models.model.FantasizeMixin" title="botorch.models.model.FantasizeMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">FantasizeMixin</span></code></a></p>
<p>Mock object that implements dummy methods and feeds through specified outputs</p>
<p>Initializes internal Module state, shared by both nn.Module and ScriptModule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>posterior</strong> (<a class="reference internal" href="#botorch.utils.testing.MockPosterior" title="botorch.utils.testing.MockPosterior"><em>MockPosterior</em></a>) – </p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">posterior_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel.posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel.posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the posterior over model outputs at the provided points.</p>
<dl class="simple">
<dt>Note: The input transforms should be applied here using</dt><dd><p><cite>self.transform_inputs(X)</cite> after the <cite>self.eval()</cite> call and before
any <cite>model.forward</cite> or <cite>model.likelihood</cite> calls.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A <cite>b x q x d</cite>-dim Tensor, where <cite>d</cite> is the dimension of the
feature space, <cite>q</cite> is the number of points considered jointly,
and <cite>b</cite> is the batch dimension.</p></li>
<li><p><strong>output_indices</strong> (<em>List</em><em>[</em><em>int</em><em>] </em><em>| </em><em>None</em>) – A list of indices, corresponding to the outputs over
which to compute the posterior (if the model is multi-output).
Can be used to speed up computation if only a subset of the
model’s outputs are required for optimization. If omitted,
computes the posterior over all model outputs.</p></li>
<li><p><strong>observation_noise</strong> (<em>bool</em>) – If True, add observation noise to the posterior.</p></li>
<li><p><strong>posterior_transform</strong> (<em>PosteriorTransform</em><em> | </em><em>None</em>) – An optional PosteriorTransform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>Posterior</cite> object, representing a batch of <cite>b</cite> joint distributions
over <cite>q</cite> points and <cite>m</cite> outputs each.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.testing.MockPosterior" title="botorch.utils.testing.MockPosterior"><em>MockPosterior</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.num_outputs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_outputs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#botorch.utils.testing.MockModel.num_outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of outputs of the model.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.batch_shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">batch_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.testing.MockModel.batch_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The batch shape of the model.</p>
<p>This is a batch shape from an I/O perspective, independent of the internal
representation of the model (as e.g. in BatchedMultiOutputGPyTorchModel).
For a model with <cite>m</cite> outputs, a <cite>test_batch_shape x q x d</cite>-shaped input <cite>X</cite>
to the <cite>posterior</cite> method returns a Posterior object over an output of
shape <cite>broadcast(test_batch_shape, model.batch_shape) x q x m</cite>.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.state_dict">
<span class="sig-name descname"><span class="pre">state_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel.state_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel.state_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary containing references to the whole state of the module.</p>
<p>Both parameters and persistent buffers (e.g. running averages) are
included. Keys are corresponding parameter and buffer names.
Parameters and buffers set to <code class="docutils literal notranslate"><span class="pre">None</span></code> are not included.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned object is a shallow copy. It contains references
to the module’s parameters and buffers.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently <code class="docutils literal notranslate"><span class="pre">state_dict()</span></code> also accepts positional arguments for
<code class="docutils literal notranslate"><span class="pre">destination</span></code>, <code class="docutils literal notranslate"><span class="pre">prefix</span></code> and <code class="docutils literal notranslate"><span class="pre">keep_vars</span></code> in order. However,
this is being deprecated and keyword arguments will be enforced in
future releases.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Please avoid the use of argument <code class="docutils literal notranslate"><span class="pre">destination</span></code> as it is not
designed for end-users.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>destination</strong> (<em>dict</em><em>, </em><em>optional</em>) – If provided, the state of module will
be updated into the dict and the same object is returned.
Otherwise, an <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> will be created and returned.
Default: <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><strong>prefix</strong> (<em>str</em><em>, </em><em>optional</em>) – a prefix added to parameter and buffer
names to compose the keys in state_dict. Default: <code class="docutils literal notranslate"><span class="pre">''</span></code>.</p></li>
<li><p><strong>keep_vars</strong> (<em>bool</em><em>, </em><em>optional</em>) – by default the <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code> s
returned in the state dict are detached from autograd. If it’s
set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, detaching will not be performed.
Default: <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a dictionary containing a whole state of the module</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># xdoctest: +SKIP("undefined vars")</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">module</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">['bias', 'weight']</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.load_state_dict">
<span class="sig-name descname"><span class="pre">load_state_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel.load_state_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel.load_state_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies parameters and buffers from <a class="reference internal" href="#botorch.utils.testing.MockModel.state_dict" title="botorch.utils.testing.MockModel.state_dict"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code></a> into
this module and its descendants. If <code class="xref py py-attr docutils literal notranslate"><span class="pre">strict</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then
the keys of <a class="reference internal" href="#botorch.utils.testing.MockModel.state_dict" title="botorch.utils.testing.MockModel.state_dict"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code></a> must exactly match the keys returned
by this module’s <code class="xref py py-meth docutils literal notranslate"><span class="pre">state_dict()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_dict</strong> (<em>dict</em>) – a dict containing parameters and
persistent buffers.</p></li>
<li><p><strong>strict</strong> (<em>bool</em><em>, </em><em>optional</em>) – whether to strictly enforce that the keys
in <a class="reference internal" href="#botorch.utils.testing.MockModel.state_dict" title="botorch.utils.testing.MockModel.state_dict"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code></a> match the keys returned by this module’s
<code class="xref py py-meth docutils literal notranslate"><span class="pre">state_dict()</span></code> function. Default: <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>missing_keys</strong> is a list of str containing the missing keys</p></li>
<li><p><strong>unexpected_keys</strong> is a list of str containing the unexpected keys</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> with <code class="docutils literal notranslate"><span class="pre">missing_keys</span></code> and <code class="docutils literal notranslate"><span class="pre">unexpected_keys</span></code> fields</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a parameter or buffer is registered as <code class="docutils literal notranslate"><span class="pre">None</span></code> and its corresponding key
exists in <a class="reference internal" href="#botorch.utils.testing.MockModel.state_dict" title="botorch.utils.testing.MockModel.state_dict"><code class="xref py py-attr docutils literal notranslate"><span class="pre">state_dict</span></code></a>, <a class="reference internal" href="#botorch.utils.testing.MockModel.load_state_dict" title="botorch.utils.testing.MockModel.load_state_dict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_state_dict()</span></code></a> will raise a
<code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code>.</p>
</div>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MockAcquisitionFunction">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MockAcquisitionFunction</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockAcquisitionFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockAcquisitionFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mock acquisition function object that implements dummy methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockAcquisitionFunction.set_X_pending">
<span class="sig-name descname"><span class="pre">set_X_pending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_pending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockAcquisitionFunction.set_X_pending"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockAcquisitionFunction.set_X_pending" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X_pending</strong> (<em>Tensor</em><em> | </em><em>None</em>) – </p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.torch">
<span id="torch"></span><h2>Torch<a class="headerlink" href="#module-botorch.utils.torch" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.torch.</span></span><span class="sig-name descname"><span class="pre">BufferDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Holds buffers in a dictionary.</p>
<p>BufferDict can be indexed like a regular Python dictionary, but buffers it
contains are properly registered, and will be visible by all Module methods.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code> is an <strong>ordered</strong> dictionary that respects</p>
<ul class="simple">
<li><p>the order of insertion, and</p></li>
<li><p>in <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>, the order of the merged <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>
or another <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code> (the argument to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>).</p></li>
</ul>
<p>Note that <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> with other unordered mapping
types (e.g., Python’s plain <code class="docutils literal notranslate"><span class="pre">dict</span></code>) does not preserve the order of the
merged mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>buffers</strong> (<em>iterable</em><em>, </em><em>optional</em>) – a mapping (dictionary) of
(string : <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) or an iterable of key-value pairs
of type (string, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>)</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyModule</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MyModule</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">({</span>
                <span class="s1">'left'</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                <span class="s1">'right'</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">})</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>buffers</strong> – A mapping (dictionary) from string to <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, or
an iterable of key-value pairs of type (string, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>).</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all items from the BufferDict.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove key from the BufferDict and return its buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>key</strong> (<em>string</em>) – key to pop from the BufferDict</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable of the BufferDict keys.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.items"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable of the BufferDict key/value pairs.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable of the BufferDict values.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffers</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code> with the key-value pairs from a
mapping or an iterable, overwriting existing keys.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">buffers</span></code> is an <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>, a <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code>,
or an iterable of key-value pairs, the order of new elements in it is
preserved.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>buffers</strong> (<em>iterable</em>) – a mapping (dictionary) from string to
<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, or an iterable of
key-value pairs of type (string, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.extra_repr">
<span class="sig-name descname"><span class="pre">extra_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.extra_repr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.extra_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the extra representation of the module</p>
<p>To print customized extra information, you should re-implement
this method in your own modules. Both single-line and multi-line
strings are acceptable.</p>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.torch.BufferDict.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.transforms">
<span id="transformations"></span><h2>Transformations<a class="headerlink" href="#module-botorch.utils.transforms" title="Permalink to this heading">¶</a></h2>
<p>Some basic data transformation helpers.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.squeeze_last_dim">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">squeeze_last_dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#squeeze_last_dim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.squeeze_last_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Squeeze the last dimension of a Tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>… x d</cite>-dim Tensor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The input tensor with last dimension squeezed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y_squeezed</span> <span class="o">=</span> <span class="n">squeeze_last_dim</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.standardize">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">standardize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#standardize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.standardize" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardizes (zero mean, unit variance) a tensor by dim=-2.</p>
<p>If the tensor is single-dimensional, simply standardizes the tensor.
If for some batch index all elements are equal (or if there is only a single
data point), this function will return 0 for that batch index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>batch_shape x n x m</cite>-dim tensor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The standardized <cite>Y</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y_standardized</span> <span class="o">=</span> <span class="n">standardize</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.normalize">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Min-max normalize X w.r.t. the provided bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – <cite>… x d</cite> tensor of data</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – <cite>2 x d</cite> tensor of lower and upper bounds for each of the X’s d
columns.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>… x d</cite>-dim tensor of normalized data, given by</dt><dd><p><cite>(X - bounds[0]) / (bounds[1] - bounds[0])</cite>. If all elements of <cite>X</cite>
are contained within <cite>bounds</cite>, the normalized values will be
contained within <cite>[0, 1]^d</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.unnormalize">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">unnormalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#unnormalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.unnormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-normalizes X w.r.t. the provided bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – <cite>… x d</cite> tensor of data</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – <cite>2 x d</cite> tensor of lower and upper bounds for each of the X’s d
columns.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>… x d</cite>-dim tensor of unnormalized data, given by</dt><dd><p><cite>X * (bounds[1] - bounds[0]) + bounds[0]</cite>. If all elements of <cite>X</cite>
are contained in <cite>[0, 1]^d</cite>, the un-normalized values will be
contained within <cite>bounds</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">unnormalize</span><span class="p">(</span><span class="n">X_normalized</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.normalize_indices">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">normalize_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#normalize_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.normalize_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize a list of indices to ensure that they are positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> (<em>List</em><em>[</em><em>int</em><em>] </em><em>| </em><em>None</em>) – A list of indices (may contain negative indices for indexing
“from the back”).</p></li>
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the tensor to index.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A normalized list of indices such that each index is between <cite>0</cite> and
<cite>d-1</cite>, or None if indices is None.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>List</em>[int] | None</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.is_fully_bayesian">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">is_fully_bayesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#is_fully_bayesian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.is_fully_bayesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if at least one model is a SaasFullyBayesianSingleTaskGP</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – A BoTorch model (may be a <cite>ModelList</cite> or <cite>ModelListGP</cite>)</p></li>
<li><p><strong>d</strong> – The dimension of the tensor to index.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if at least one model is a <cite>SaasFullyBayesianSingleTaskGP</cite></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.t_batch_mode_transform">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">t_batch_mode_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expected_q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assert_output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#t_batch_mode_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.t_batch_mode_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for decorators enabling consistent t-batch behavior.</p>
<p>This method creates decorators for instance methods to transform an input tensor
<cite>X</cite> to t-batch mode (i.e. with at least 3 dimensions). This assumes the tensor
has a q-batch dimension. The decorator also checks the q-batch size if <cite>expected_q</cite>
is provided, and the output shape if <cite>assert_output_shape</cite> is <cite>True</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expected_q</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>) – The expected q-batch size of <cite>X</cite>. If specified, this will raise an
AssertionError if <cite>X</cite>’s q-batch size does not equal expected_q.</p></li>
<li><p><strong>assert_output_shape</strong> (<em>bool</em>) – If <cite>True</cite>, this will raise an AssertionError if the
output shape does not match either the t-batch shape of <cite>X</cite>,
or the <cite>acqf.model.batch_shape</cite> for acquisition functions using
batched models.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The decorated instance method.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Callable[[Callable[[AcquisitionFunction, Any], Any]], Callable[[AcquisitionFunction, Any], Any]]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ExampleClass</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@t_batch_mode_transform</span><span class="p">(</span><span class="n">expected_q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span> <span class="nf">single_q_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="o">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@t_batch_mode_transform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span> <span class="nf">arbitrary_q_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="o">...</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.concatenate_pending_points">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">concatenate_pending_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#concatenate_pending_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.concatenate_pending_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator concatenating X_pending into an acquisition function’s argument.</p>
<p>This decorator works on the <cite>forward</cite> method of acquisition functions taking
a tensor <cite>X</cite> as the argument. If the acquisition function has an <cite>X_pending</cite>
attribute (that is not <cite>None</cite>), this is concatenated into the input <cite>X</cite>,
appropriately expanding the pending points to match the batch shape of <cite>X</cite>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">ExampleAcquisitionFunction</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@concatenate_pending_points</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@t_batch_mode_transform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="o">...</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>method</strong> (<em>Callable</em><em>[</em><em>[</em><em>Any</em><em>, </em><em>Tensor</em><em>]</em><em>, </em><em>Any</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Callable</em>[[<em>Any</em>, <em>Tensor</em>], <em>Any</em>]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.match_batch_shape">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">match_batch_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#match_batch_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.match_batch_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches the batch dimension of a tensor to that of another tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A <cite>batch_shape_X x q x d</cite> tensor, whose batch dimensions that
correspond to batch dimensions of <cite>Y</cite> are to be matched to those
(if compatible).</p></li>
<li><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>batch_shape_Y x q’ x d</cite> tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape_Y x q x d</cite> tensor containing the data of <cite>X</cite> expanded to
the batch dimensions of <cite>Y</cite> (if compatible). For instance, if <cite>X</cite> is
<cite>b’’ x b’ x q x d</cite> and <cite>Y</cite> is <cite>b x q x d</cite>, then the returned tensor is
<cite>b’’ x b x q x d</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_matched</span> <span class="o">=</span> <span class="n">match_batch_shape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_matched</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([2, 6, 5, 3])</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.convert_to_target_pre_hook">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">convert_to_target_pre_hook</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#convert_to_target_pre_hook"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.convert_to_target_pre_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-hook for automatically calling <cite>.to(X)</cite> on module prior to <cite>forward</cite></p>
</dd></dl>
</section>
<section id="module-botorch.utils.feasible_volume">
<span id="feasible-volume"></span><h2>Feasible Volume<a class="headerlink" href="#module-botorch.utils.feasible_volume" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.feasible_volume.get_feasible_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.feasible_volume.</span></span><span class="sig-name descname"><span class="pre">get_feasible_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/feasible_volume.html#get_feasible_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.feasible_volume.get_feasible_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks which of the samples satisfy all of the inequality constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samples</strong> (<em>Tensor</em>) – A <cite>sample size x d</cite> size tensor of feature samples,
where d is a feature dimension.</p></li>
<li><p><strong>constraints</strong> (<em>inequality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>List</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>2-element tuple containing</p>
<ul class="simple">
<li><p>Samples satisfying the linear constraints.</p></li>
<li><p>Estimated proportion of samples satisfying the linear constraints.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tuple</em>[<em>Tensor</em>, float]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.feasible_volume.get_outcome_feasibility_probability">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.feasible_volume.</span></span><span class="sig-name descname"><span class="pre">get_outcome_feasibility_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/feasible_volume.html#get_outcome_feasibility_probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.feasible_volume.get_outcome_feasibility_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo estimate of the feasible volume with respect to the outcome constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – The model used for sampling the posterior.</p></li>
<li><p><strong>X</strong> (<em>Tensor</em>) – A tensor of dimension <cite>batch-shape x 1 x d</cite>, where d is feature dimension.</p></li>
<li><p><strong>outcome_constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of dimension
<cite>sample_shape x batch-shape x q x m</cite> to a Tensor of dimension
<cite>sample_shape x batch-shape x q</cite>, where negative values imply feasibility.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – A lower limit for the probability of posterior samples feasibility.</p></li>
<li><p><strong>nsample_outcome</strong> (<em>int</em>) – The number of samples from the model posterior.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed for the posterior sampler. If omitted, use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Estimated proportion of features for which posterior samples satisfy
given outcome constraints with probability above or equal to
the given threshold.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.feasible_volume.estimate_feasible_volume">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.feasible_volume.</span></span><span class="sig-name descname"><span class="pre">estimate_feasible_volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample_feature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/feasible_volume.html#estimate_feasible_volume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.feasible_volume.estimate_feasible_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo estimate of the feasible volume with respect
to feature constraints and outcome constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite> tensor of lower and upper bounds
for each column of <cite>X</cite>.</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – The model used for sampling the outcomes.</p></li>
<li><p><strong>outcome_constraints</strong> (<em>List</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of dimension
<cite>sample_shape x batch-shape x q x m</cite> to a Tensor of dimension
<cite>sample_shape x batch-shape x q</cite>, where negative values imply
feasibility.</p></li>
<li><p><strong>constraints</strong> (<em>inequality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>nsample_feature</strong> (<em>int</em>) – The number of feature samples satisfying the bounds.</p></li>
<li><p><strong>nsample_outcome</strong> (<em>int</em>) – The number of outcome samples from the model posterior.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – A lower limit for the probability of outcome feasibility</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed for both feature and outcome samplers. If omitted,
use a random seed.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – An indicator for whether to log the results.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>List</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>) – </p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – </p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><dl class="simple">
<dt>Estimated proportion of volume in feature space that is</dt><dd><p>feasible wrt the bounds and the inequality constraints (linear).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Estimated proportion of feasible features for which</dt><dd><p>posterior samples (outcome) satisfies the outcome constraints
with probability above the given threshold.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2-element tuple containing</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.types">
<span id="types-and-type-hints"></span><h2>Types and Type Hints<a class="headerlink" href="#module-botorch.utils.types" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.types.DEFAULT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.types.</span></span><span class="sig-name descname"><span class="pre">DEFAULT</span></span><a class="headerlink" href="#botorch.utils.types.DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>
</section>
<section id="module-botorch.utils.constants">
<span id="constants"></span><h2>Constants<a class="headerlink" href="#module-botorch.utils.constants" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.constants.get_constants">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.constants.</span></span><span class="sig-name descname"><span class="pre">get_constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constants.html#get_constants"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constants.get_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns scalar-valued Tensors containing each of the given constants.
Used to expedite tensor operations involving scalar arithmetic. Note that
the returned Tensors should not be modified in-place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Number</em><em> | </em><em>Iterator</em><em>[</em><em>Number</em><em>]</em>) – </p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – </p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em> | <em>Tuple</em>[<em>Tensor</em>, …]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.constants.get_constants_like">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.constants.</span></span><span class="sig-name descname"><span class="pre">get_constants_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constants.html#get_constants_like"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constants.get_constants_like" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Number</em><em> | </em><em>Iterator</em><em>[</em><em>Number</em><em>]</em>) – </p></li>
<li><p><strong>ref</strong> (<em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em> | <em>Iterator</em>[<em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.safe_math">
<span id="safe-math"></span><h2>Safe Math<a class="headerlink" href="#module-botorch.utils.safe_math" title="Permalink to this heading">¶</a></h2>
<p>Special implementations of mathematical functions that
solve numerical issues of naive implementations.</p>
<div class="citation-list" role="list">
<div class="citation" id="maechler2012accurate" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Maechler2012accurate<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a href="#id4" role="doc-backlink">1</a>,<a href="#id5" role="doc-backlink">2</a>)</span>
<ol class="upperalpha simple" start="13">
<li><dl class="simple">
<dt>Mächler. Accurately Computing log (1 - exp (-| a|))</dt><dd><p>Assessed by the Rmpfr package. Technical report, 2012.</p>
</dd>
</dl>
</li>
</ol>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.exp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.exp" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.add">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.add" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.sub">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#sub"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.sub" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.div">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#div"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.div" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.mul">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#mul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.mul" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log1mexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log1mexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log1mexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log1mexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically accurate evaluation of log(1 - exp(x)) for x &lt; 0.
See <a class="reference internal" href="#maechler2012accurate" id="id4"><span>[Maechler2012accurate]</span></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log1pexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log1pexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log1pexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log1pexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically accurate evaluation of log(1 + exp(x)).
See <a class="reference internal" href="#maechler2012accurate" id="id5"><span>[Maechler2012accurate]</span></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.logexpit">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">logexpit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#logexpit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.logexpit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the logarithm of the expit (a.k.a. sigmoid) function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.logdiffexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">logdiffexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#logdiffexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.logdiffexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes log(b - a) accurately given log(a) and log(b).
Assumes, log_b &gt; log_a, i.e. b &gt; a &gt; 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>log_a</strong> (<em>Tensor</em>) – The logarithm of a, assumed to be less than log_b.</p></li>
<li><p><strong>log_b</strong> (<em>Tensor</em>) – The logarithm of b, assumed to be larger than log_a.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of values corresponding to log(b - a).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.logmeanexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">logmeanexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#logmeanexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.logmeanexp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes <cite>log(mean(exp(X), dim=dim, keepdim=keepdim))</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – Values of which to compute the logmeanexp.</p></li>
<li><p><strong>dim</strong> (<em>int</em><em> | </em><em>Tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em>) – The dimension(s) over which to compute the mean.</p></li>
<li><p><strong>keepdim</strong> (<em>bool</em>) – If True, keeps the reduced dimensions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of values corresponding to <cite>log(mean(exp(X), dim=dim))</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log_softplus">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log_softplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log_softplus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log_softplus" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the logarithm of the softplus function with high numerical accuracy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Tensor</em>) – Input tensor, should have single or double precision floats.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Decreasing tau increases the tightness of the
approximation to ReLU. Non-negative and defaults to 1.0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tensor corresponding to <cite>log(softplus(x))</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.smooth_amax">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">smooth_amax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#smooth_amax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.smooth_amax" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a smooth approximation to <cite>max(X, dim=dim)</cite>, i.e the maximum value of
<cite>X</cite> over dimension <cite>dim</cite>, using the logarithm of the <cite>l_(1/tau)</cite> norm of <cite>exp(X)</cite>.
Note that when <cite>X = log(U)</cite> is the <em>logarithm</em> of an acquisition utility <cite>U</cite>,</p>
<p><cite>logsumexp(log(U) / tau) * tau = log(sum(U^(1/tau))^tau) = log(norm(U, ord=(1/tau))</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A Tensor from which to compute the smoothed amax.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smooth approximation
to max operator, becomes tighter as tau goes to 0. Needs to be positive.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of smooth approximations to <cite>max(X, dim=dim)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.check_dtype_float32_or_float64">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">check_dtype_float32_or_float64</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#check_dtype_float32_or_float64"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.check_dtype_float32_or_float64" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log_fatplus">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log_fatplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log_fatplus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log_fatplus" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the logarithm of the fat-tailed softplus.</p>
<p>NOTE: Separated out in case the complexity of the <cite>log</cite> implementation increases
in the future.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.fatplus">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">fatplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#fatplus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.fatplus" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a fat-tailed approximation to <cite>ReLU(x) = max(x, 0)</cite> by linearly
combining a regular softplus function and the density function of a Cauchy
distribution. The coefficient <cite>alpha</cite> of the Cauchy density is chosen to guarantee
monotonicity and convexity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Tensor</em>) – A Tensor on whose values to compute the smoothed function.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of values of the fat-tailed softplus.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.fatmax">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">fatmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#fatmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.fatmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a smooth approximation to amax(X, dim=dim) with a fat tail.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A Tensor from which to compute the smoothed amax.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smooth approximation
to max operator, becomes tighter as tau goes to 0. Needs to be positive.</p></li>
<li><p><strong>standardize</strong> – Toggles the temperature standardization of the smoothed function.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of smooth approximations to <cite>max(X, dim=dim)</cite> with a fat tail.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log_fatmoid">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log_fatmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log_fatmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log_fatmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the logarithm of the fatmoid. Separated out in case the implementation
of the logarithm becomes more complex in the future to ensure numerical stability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.fatmoid">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">fatmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#fatmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.fatmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a twice continuously differentiable approximation to the Heaviside
step function with a fat tail, i.e. <cite>O(1 / x^2)</cite> as <cite>x</cite> goes to -inf.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A Tensor from which to compute the smoothed step function.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smoothness of the approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of fat-tailed approximations to the Heaviside step function.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.cauchy">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">cauchy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#cauchy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.cauchy" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a Lorentzian, i.e. an un-normalized Cauchy density function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.sigmoid">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#sigmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>A sigmoid function with an optional fat tail and evaluation in log space for
better numerical behavior. Notably, the fat-tailed sigmoid can be used to remedy
numerical underflow problems in the value and gradient of the canonical sigmoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – The Tensor on which to evaluate the sigmoid.</p></li>
<li><p><strong>log</strong> (<em>bool</em>) – Toggles the evaluation of the log sigmoid.</p></li>
<li><p><strong>fat</strong> (<em>bool</em>) – Toggles the evaluation of the fat-tailed sigmoid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of (log-)sigmoid values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<section id="multi-objective-utilities">
<h3>Multi-Objective Utilities<a class="headerlink" href="#multi-objective-utilities" title="Permalink to this heading">¶</a></h3>
</section>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.box_decomposition">
<span id="abstract-box-decompositions"></span><h2>Abstract Box Decompositions<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.box_decomposition" title="Permalink to this heading">¶</a></h2>
<p>Box decomposition algorithms.</p>
<p>References</p>
<div class="citation-list" role="list">
<div class="citation" id="lacour17" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Lacour17<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a href="#id6" role="doc-backlink">1</a>,<a href="#id7" role="doc-backlink">2</a>,<a href="#id8" role="doc-backlink">3</a>,<a href="#id15" role="doc-backlink">4</a>,<a href="#id16" role="doc-backlink">5</a>)</span>
<p>R. Lacour, K. Klamroth, C. Fonseca. A box decomposition algorithm to
compute the hypervolume indicator. Computers &amp; Operations Research,
Volume 79, 2017.</p>
</div>
</div>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.box_decomposition_list">
<span id="box-decomposition-list"></span><h2>Box Decomposition List<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.box_decomposition_list" title="Permalink to this heading">¶</a></h2>
<p>Box decomposition container.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition_list.</span></span><span class="sig-name descname"><span class="pre">BoxDecompositionList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">box_decompositions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>A list of box decompositions.</p>
<p>Initialize the box decomposition list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>*box_decompositions</strong> (<em>BoxDecomposition</em>) – An variable number of box decompositions</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd1</span> <span class="o">=</span> <span class="n">FastNondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bd2</span> <span class="o">=</span> <span class="n">FastNondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">BoxDecompositionList</span><span class="p">(</span><span class="n">bd1</span><span class="p">,</span> <span class="n">bd2</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.pareto_Y">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pareto_Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tensor</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.pareto_Y" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns the non-dominated set.</p>
<p>Note: Internally, we store the negative pareto set (minimization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A list where the ith element is the <cite>n_pareto_i x m</cite>-dim tensor</dt><dd><p>of pareto optimal outcomes for each box_decomposition <cite>i</cite>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.ref_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ref_point</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.ref_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the reference point.</p>
<p>Note: Internally, we store the negative reference point (minimization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>n_box_decompositions x m</cite>-dim tensor of outcomes.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.get_hypercell_bounds">
<span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.get_hypercell_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>2 x n_box_decompositions x num_cells x num_outcomes</cite>-dim tensor</dt><dd><p>containing the lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the partitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>List</em><em>[</em><em>Tensor</em><em>] </em><em>| </em><em>Tensor</em>) – A <cite>n_box_decompositions x n x num_outcomes</cite>-dim tensor or a list
where the ith  element contains the new points for
box_decomposition <cite>i</cite>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.compute_hypervolume">
<span class="sig-name descname"><span class="pre">compute_hypervolume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList.compute_hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.compute_hypervolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute hypervolume that is dominated by the Pareto Froniter.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>(batch_shape)</cite>-dim tensor containing the hypervolume dominated by</dt><dd><p>each Pareto frontier.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.utils">
<span id="box-decomposition-utilities"></span><h2>Box Decomposition Utilities<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.utils" title="Permalink to this heading">¶</a></h2>
<p>Utilities for box decomposition algorithms.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.compute_local_upper_bounds">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">compute_local_upper_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#compute_local_upper_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_local_upper_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute local upper bounds.</p>
<p>Note: this assumes minimization.</p>
<p>This uses the incremental algorithm (Alg. 1) from <a class="reference internal" href="#lacour17" id="id6"><span>[Lacour17]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor containing the local upper bounds.</p></li>
<li><p><strong>Z</strong> (<em>Tensor</em>) – A <cite>n x m x m</cite>-dim tensor containing the defining points.</p></li>
<li><p><strong>z</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the new point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A new <cite>n’ x m</cite>-dim tensor local upper bounds.</p></li>
<li><p>A <cite>n’ x m x m</cite>-dim tensor containing the defining points.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2-element tuple containing</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.get_partition_bounds">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">get_partition_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#get_partition_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.get_partition_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the cell bounds given the local upper bounds and the defining points.</p>
<p>This implements Equation 2 in <a class="reference internal" href="#lacour17" id="id7"><span>[Lacour17]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Z</strong> (<em>Tensor</em>) – A <cite>n x m x m</cite>-dim tensor containing the defining points. The first
dimension corresponds to u_idx, the second dimension corresponds to j,
and Z[u_idx, j] is the set of definining points Z^j(u) where
u = U[u_idx].</p></li>
<li><p><strong>U</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor containing the local upper bounds.</p></li>
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>2 x num_cells x m</cite>-dim tensor containing the lower and upper vertices</dt><dd><p>bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.update_local_upper_bounds_incremental">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">update_local_upper_bounds_incremental</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_pareto_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#update_local_upper_bounds_incremental"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.update_local_upper_bounds_incremental" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the current local upper with the new pareto points.</p>
<p>This assumes minimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_pareto_Y</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor containing the new
Pareto points.</p></li>
<li><p><strong>U</strong> (<em>Tensor</em>) – A <cite>n’ x m</cite>-dim tensor containing the local upper bounds.</p></li>
<li><p><strong>Z</strong> (<em>Tensor</em>) – A <cite>n x m x m</cite>-dim tensor containing the defining points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A new <cite>n’ x m</cite>-dim tensor local upper bounds.</p></li>
<li><p>A <cite>n’ x m x m</cite>-dim tensor containing the defining points</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2-element tuple containing</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.compute_non_dominated_hypercell_bounds_2d">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">compute_non_dominated_hypercell_bounds_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y_sorted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#compute_non_dominated_hypercell_bounds_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_non_dominated_hypercell_bounds_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an axis-aligned partitioning of the non-dominated space for 2
objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pareto_Y_sorted</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x n_pareto x 2</cite>-dim tensor of pareto outcomes
that are sorted by the 0th dimension in increasing order. All points must be
better than the reference point.</p></li>
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x 2</cite>-dim reference point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>2 x (batch_shape) x n_pareto + 1 x m</cite>-dim tensor of cell bounds.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.compute_dominated_hypercell_bounds_2d">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">compute_dominated_hypercell_bounds_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y_sorted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#compute_dominated_hypercell_bounds_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_dominated_hypercell_bounds_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an axis-aligned partitioning of the dominated space for 2-objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pareto_Y_sorted</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x n_pareto x 2</cite>-dim tensor of pareto outcomes
that are sorted by the 0th dimension in increasing order.</p></li>
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>2</cite>-dim reference point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>2 x (batch_shape) x n_pareto x m</cite>-dim tensor of cell bounds.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.dominated">
<span id="dominated-partitionings"></span><h2>Dominated Partitionings<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.dominated" title="Permalink to this heading">¶</a></h2>
<p>Algorithms for partitioning the dominated space into hyperrectangles.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.dominated.</span></span><span class="sig-name descname"><span class="pre">DominatedPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/dominated.html#DominatedPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">FastPartitioning</span></code></p>
<p>Partition dominated space into axis-aligned hyperrectangles.</p>
<p>This uses the Algorithm 1 from <a class="reference internal" href="#lacour17" id="id8"><span>[Lacour17]</span></a>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">DominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.hypervolume">
<span id="hypervolume"></span><h2>Hypervolume<a class="headerlink" href="#module-botorch.utils.multi_objective.hypervolume" title="Permalink to this heading">¶</a></h2>
<p>Hypervolume Utilities.</p>
<p>References</p>
<div class="citation-list" role="list">
<div class="citation" id="fonseca2006" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Fonseca2006<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a href="#id10" role="doc-backlink">1</a>,<a href="#id11" role="doc-backlink">2</a>)</span>
<p>C. M. Fonseca, L. Paquete, and M. Lopez-Ibanez. An improved dimension-sweep
algorithm for the hypervolume indicator. In IEEE Congress on Evolutionary
Computation, pages 1157-1163, Vancouver, Canada, July 2006.</p>
</div>
<div class="citation" id="ishibuchi2011" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a href="#id9" role="doc-backlink">Ishibuchi2011</a><span class="fn-bracket">]</span></span>
<p>H. Ishibuchi, N. Akedo, and Y. Nojima. A many-objective test problem
for visually examining diversity maintenance behavior in a decision
space. Proc. 13th Annual Conf. Genetic Evol. Comput., 2011.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.infer_reference_point">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">infer_reference_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_ref_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_max_ref_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#infer_reference_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.infer_reference_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get reference point for hypervolume computations.</p>
<p>This sets the reference point to be <cite>ref_point = nadir - scale * range</cite>
when there is no <cite>pareto_Y</cite> that is better than <cite>max_ref_point</cite>.
If there’s <cite>pareto_Y</cite> better than <cite>max_ref_point</cite>, the reference point
will be set to <cite>max_ref_point - scale * range</cite> if <cite>scale_max_ref_point</cite>
is true and to <cite>max_ref_point</cite> otherwise.</p>
<p><a class="reference internal" href="#ishibuchi2011" id="id9"><span>[Ishibuchi2011]</span></a> find 0.1 to be a robust multiplier for scaling the
nadir point.</p>
<p>Note: this assumes maximization of all objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pareto_Y</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor of Pareto-optimal points.</p></li>
<li><p><strong>max_ref_point</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>m</cite> dim tensor indicating the maximum reference point.
Some elements can be NaN, except when <cite>pareto_Y</cite> is empty,
in which case these dimensions will be treated as if no
<cite>max_ref_point</cite> was provided and set to <cite>nadir - scale * range</cite>.</p></li>
<li><p><strong>scale</strong> (<em>float</em>) – A multiplier used to scale back the reference point based on the
range of each objective.</p></li>
<li><p><strong>scale_max_ref_point</strong> (<em>bool</em>) – A boolean indicating whether to apply scaling to
the max_ref_point based on the range of each objective.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>m</cite>-dim tensor containing the reference point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Hypervolume">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">Hypervolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#Hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Hypervolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Hypervolume computation dimension sweep algorithm from <a class="reference internal" href="#fonseca2006" id="id10"><span>[Fonseca2006]</span></a>.</p>
<p>Adapted from Simon Wessing’s implementation of the algorithm
(Variant 3, Version 1.2) in <a class="reference internal" href="#fonseca2006" id="id11"><span>[Fonseca2006]</span></a> in PyMOO:
<a class="reference external" href="https://github.com/msu-coinlab/pymoo/blob/master/pymoo/vendor/hv.py">https://github.com/msu-coinlab/pymoo/blob/master/pymoo/vendor/hv.py</a></p>
<p>Maximization is assumed.</p>
<p>TODO: write this in C++ for faster looping.</p>
<p>Initialize hypervolume object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ref_point</strong> (<em>Tensor</em>) – <cite>m</cite>-dim Tensor containing the reference point.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Hypervolume.ref_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ref_point</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Hypervolume.ref_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Get reference point (for maximization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>m</cite>-dim tensor containing the reference point.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Hypervolume.compute">
<span class="sig-name descname"><span class="pre">compute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#Hypervolume.compute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Hypervolume.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute hypervolume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pareto_Y</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor of pareto optimal outcomes</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The hypervolume.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.sort_by_dimension">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">sort_by_dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#sort_by_dimension"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.sort_by_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the list of nodes in-place by the specified objective.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes</strong> (<em>List</em><em>[</em><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a><em>]</em>) – A list of Nodes</p></li>
<li><p><strong>i</strong> (<em>int</em>) – The index of the objective to sort by</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Node">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">Node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#Node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Node in the MultiList data structure.</p>
<p>Initialize MultiList.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – The number of objectives</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em>) – The dtype</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – The device</p></li>
<li><p><strong>data</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – The tensor data to be stored in this Node.</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">MultiList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A special data structure used in hypervolume computation.</p>
<p>It consists of several doubly linked lists that share common nodes.
Every node has multiple predecessors and successors, one in every list.</p>
<p>Initialize <cite>m</cite> doubly linked lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – number of doubly linked lists</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em>) – the dtype</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – the device</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends a node to the end of the list at the given index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a>) – the new node</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the index where the node should be appended.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.extend"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends the list at the given index with the nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes</strong> (<em>List</em><em>[</em><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a><em>]</em>) – list of nodes to append at the given index.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the index where the nodes should be appended.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.remove"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes and returns ‘node’ from all lists in [0, ‘index’].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a>) – The node to remove</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The upper bound on the range of indices</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x m</cite>-dim tensor bounds on the objectives</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.reinsert">
<span class="sig-name descname"><span class="pre">reinsert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.reinsert"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.reinsert" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-inserts the node at its original position.</p>
<p>Re-inserts the node at its original position in all lists in [0, ‘index’]
before it was removed. This method assumes that the next and previous
nodes of the node that is reinserted are in the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a>) – The node</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The upper bound on the range of indices</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x m</cite>-dim tensor bounds on the objectives</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.non_dominated">
<span id="non-dominated-partitionings"></span><h2>Non-dominated Partitionings<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.non_dominated" title="Permalink to this heading">¶</a></h2>
<p>Algorithms for partitioning the non-dominated space into rectangles.</p>
<p>References</p>
<div class="citation-list" role="list">
<div class="citation" id="couckuyt2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Couckuyt2012<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a href="#id12" role="doc-backlink">1</a>,<a href="#id13" role="doc-backlink">2</a>)</span>
<p>I. Couckuyt, D. Deschrijver and T. Dhaene, “Towards Efficient
Multiobjective Optimization: Multiobjective statistical criterions,”
2012 IEEE Congress on Evolutionary Computation, Brisbane, QLD, 2012,
pp. 1-8.</p>
</div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.non_dominated.</span></span><span class="sig-name descname"><span class="pre">NondominatedPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#NondominatedPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BoxDecomposition</span></code></p>
<p>A class for partitioning the non-dominated space into hyper-cells.</p>
<p>Note: this assumes maximization. Internally, it multiplies outcomes by -1 and
performs the decomposition under minimization. TODO: use maximization
internally as well.</p>
<p>Note: it is only feasible to use this algorithm to compute an exact
decomposition of the non-dominated space for <cite>m&lt;5</cite> objectives (alpha=0.0).</p>
<p>The alpha parameter can be increased to obtain an approximate partitioning
faster. The <cite>alpha</cite> is a fraction of the total hypervolume encapsuling the
entire Pareto set. When a hypercell’s volume divided by the total hypervolume
is less than <cite>alpha</cite>, we discard the hypercell. See Figure 2 in
<a class="reference internal" href="#couckuyt2012" id="id12"><span>[Couckuyt2012]</span></a> for a visual representation.</p>
<p>This PyTorch implementation of the binary partitioning algorithm (<a class="reference internal" href="#couckuyt2012" id="id13"><span>[Couckuyt2012]</span></a>)
is adapted from numpy/tensorflow implementation at:
<a class="reference external" href="https://github.com/GPflow/GPflowOpt/blob/master/gpflowopt/pareto.py">https://github.com/GPflow/GPflowOpt/blob/master/gpflowopt/pareto.py</a>.</p>
<p>TODO: replace this with a more efficient decomposition. E.g.
<a class="reference external" href="https://link.springer.com/content/pdf/10.1007/s10898-019-00798-7.pdf">https://link.springer.com/content/pdf/10.1007/s10898-019-00798-7.pdf</a></p>
<p>Initialize NondominatedPartitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – A thresold fraction of total volume used in an approximate
decomposition.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">NondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.get_hypercell_bounds">
<span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#NondominatedPartitioning.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.get_hypercell_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ref_point</strong> – A <cite>(batch_shape) x m</cite>-dim tensor containing the reference point.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>2 x num_cells x m</cite>-dim tensor containing the</dt><dd><p>lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.non_dominated.</span></span><span class="sig-name descname"><span class="pre">FastNondominatedPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#FastNondominatedPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">FastPartitioning</span></code></p>
<p>A class for partitioning the non-dominated space into hyper-cells.</p>
<p>Note: this assumes maximization. Internally, it multiplies by -1 and performs
the decomposition under minimization.</p>
<p>This class is far more efficient than NondominatedPartitioning for exact box
partitionings</p>
<dl class="simple">
<dt>This class uses the two-step approach similar to that in <a class="reference internal" href="acquisition.html#yang2019" id="id14"><span>[Yang2019]</span></a>, where:</dt><dd><ol class="loweralpha simple">
<li><dl class="simple">
<dt>first, Alg 1 from <a class="reference internal" href="#lacour17" id="id15"><span>[Lacour17]</span></a> is used to find the local lower bounds</dt><dd><p>for the maximization problem</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>second, the local lower bounds are used as the Pareto frontier for the</dt><dd><p>minimization problem, and <a class="reference internal" href="#lacour17" id="id16"><span>[Lacour17]</span></a> is applied again to partition
the space dominated by that Pareto frontier.</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<p>Initialize FastNondominatedPartitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">FastNondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.pareto">
<span id="pareto"></span><h2>Pareto<a class="headerlink" href="#module-botorch.utils.multi_objective.pareto" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.pareto.is_non_dominated">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.pareto.</span></span><span class="sig-name descname"><span class="pre">is_non_dominated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deduplicate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/pareto.html#is_non_dominated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.pareto.is_non_dominated" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the non-dominated front.</p>
<p>Note: this assumes maximization.</p>
<p>For small <cite>n</cite>, this method uses a highly parallel methodology
that compares all pairs of points in Y. However, this is memory
intensive and slow for large <cite>n</cite>. For large <cite>n</cite> (or if Y is larger
than 5MB), this method will dispatch to a loop-based approach
that is faster and has a lower memory footprint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor of outcomes.</p></li>
<li><p><strong>deduplicate</strong> (<em>bool</em>) – A boolean indicating whether to only return
unique points on the pareto frontier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>(batch_shape) x n</cite>-dim boolean tensor indicating whether
each point is non-dominated.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.multi_objective.scalarization">
<span id="scalarization"></span><h2>Scalarization<a class="headerlink" href="#module-botorch.utils.multi_objective.scalarization" title="Permalink to this heading">¶</a></h2>
<p>Helper utilities for constructing scalarizations.</p>
<p>References</p>
<div class="citation-list" role="list">
<div class="citation" id="knowles2005" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Knowles2005<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a href="#id17" role="doc-backlink">1</a>,<a href="#id19" role="doc-backlink">2</a>)</span>
<p>J. Knowles, “ParEGO: a hybrid algorithm with on-line landscape approximation
for expensive multiobjective optimization problems,” in IEEE Transactions
on Evolutionary Computation, vol. 10, no. 1, pp. 50-66, Feb. 2006.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.scalarization.get_chebyshev_scalarization">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.scalarization.</span></span><span class="sig-name descname"><span class="pre">get_chebyshev_scalarization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/scalarization.html#get_chebyshev_scalarization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.scalarization.get_chebyshev_scalarization" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an augmented Chebyshev scalarization.</p>
<dl class="simple">
<dt>The augmented Chebyshev scalarization is given by</dt><dd><p>g(y) = max_i(w_i * y_i) + alpha * sum_i(w_i * y_i)</p>
</dd>
</dl>
<p>where the goal is to minimize g(y) in the setting where all objectives y_i are
to be minimized. Since the default in BoTorch is to maximize all objectives,
this method constructs a Chebyshev scalarization where the inputs are first
multiplied by -1, so that all objectives are to be minimized. Then, it computes
g(y) (which should be minimized), and returns -g(y), which should be maximized.</p>
<p>Minimizing an objective is supported by passing a negative
weight for that objective. To make all w * y’s have the same sign
such that they are comparable when computing max(w * y), outcomes of minimization
objectives are shifted from [0,1] to [-1,0].</p>
<p>See <a class="reference internal" href="#knowles2005" id="id17"><span>[Knowles2005]</span></a> for details.</p>
<p>This scalarization can be used with qExpectedImprovement to implement q-ParEGO
as proposed in <a class="reference internal" href="acquisition.html#daulton2020qehvi" id="id18"><span>[Daulton2020qehvi]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor of weights.
Positive for maximization and negative for minimization.</p></li>
<li><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor of observed outcomes, which are used for
scaling the outcomes to [0,1] or [-1,0]. If <cite>n=0</cite>, then outcomes
are left unnormalized.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Parameter governing the influence of the weighted sum term. The
default value comes from <a class="reference internal" href="#knowles2005" id="id19"><span>[Knowles2005]</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transform function using the objective weights.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Callable</em>[[<em>Tensor</em>, <em>Tensor</em> | None], <em>Tensor</em>]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span> <span class="o">=</span> <span class="n">get_aug_chebyshev_scalarization</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<section id="probability-utilities">
<h3>Probability Utilities<a class="headerlink" href="#probability-utilities" title="Permalink to this heading">¶</a></h3>
</section>
</section>
<section id="module-botorch.utils.probability.mvnxpb">
<span id="multivariate-gaussian-probabilities-via-bivariate-conditioning"></span><h2>Multivariate Gaussian Probabilities via Bivariate Conditioning<a class="headerlink" href="#module-botorch.utils.probability.mvnxpb" title="Permalink to this heading">¶</a></h2>
<p>Bivariate conditioning algorithm for approximating Gaussian probabilities,
see <a class="reference internal" href="#genz2016numerical" id="id20"><span>[Genz2016numerical]</span></a> and <a class="reference internal" href="#trinh2015bivariate" id="id21"><span>[Trinh2015bivariate]</span></a>.</p>
<div class="citation-list" role="list">
<div class="citation" id="trinh2015bivariate" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Trinh2015bivariate<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a href="#id21" role="doc-backlink">1</a>,<a href="#id22" role="doc-backlink">2</a>)</span>
<p>G. Trinh and A. Genz. Bivariate conditioning approximations for
multivariate normal probabilities. Statistics and Computing, 2015.</p>
</div>
<div class="citation" id="genz2016numerical" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a href="#id20" role="doc-backlink">Genz2016numerical</a><span class="fn-bracket">]</span></span>
<p>A. Genz and G. Tring. Numerical Computation of Multivariate Normal Probabilities
using Bivariate Conditioning. Monte Carlo and Quasi-Monte Carlo Methods, 2016.</p>
</div>
<div class="citation" id="gibson1994monte" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a href="#id23" role="doc-backlink">Gibson1994monte</a><span class="fn-bracket">]</span></span>
<p>GJ. Gibson, CA Galsbey, and DA Elston. Monte Carlo evaluation of multivariate normal
integrals and sensitivity to variate ordering. Advances in Numerical Methods and
Applications. 1994.</p>
</div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.mvnxpb.</span></span><span class="sig-name descname"><span class="pre">mvnxpbState</span></span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#mvnxpbState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.step">
<span class="sig-name descname"><span class="pre">step</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.perm">
<span class="sig-name descname"><span class="pre">perm</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">LongTensor</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.perm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.bounds">
<span class="sig-name descname"><span class="pre">bounds</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.piv_chol">
<span class="sig-name descname"><span class="pre">piv_chol</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><span class="pre">PivotedCholesky</span></a></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.piv_chol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.plug_ins">
<span class="sig-name descname"><span class="pre">plug_ins</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.plug_ins" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.log_prob">
<span class="sig-name descname"><span class="pre">log_prob</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.log_prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.log_prob_extra">
<span class="sig-name descname"><span class="pre">log_prob_extra</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.log_prob_extra" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.mvnxpb.</span></span><span class="sig-name descname"><span class="pre">MVNXPB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">covariance_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An algorithm for approximating Gaussian probabilities <cite>P(X in bounds)</cite>, where
<cite>X ~ N(0, covariance_matrix)</cite>.</p>
<p>Initializes an MVNXPB instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>covariance_matrix</strong> (<em>Tensor</em>) – Covariance matrices of shape <cite>batch_shape x [n, n]</cite>.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – Tensor of lower and upper bounds, <cite>batch_shape x [n, 2]</cite>. These
bounds are standardized internally and clipped to STANDARDIZED_RANGE.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.build">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">piv_chol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plug_ins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_prob</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_prob_extra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an MVNXPB instance from raw arguments. Unlike MVNXPB.__init__,
this methods does not preprocess or copy terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>step</strong> (<em>int</em>) – Integer used to track the solver’s progress.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – Tensor of lower and upper bounds, <cite>batch_shape x [n, 2]</cite>.</p></li>
<li><p><strong>piv_chol</strong> (<a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a>) – A PivotedCholesky instance for the system.</p></li>
<li><p><strong>plug_ins</strong> (<em>Tensor</em>) – Tensor of plug-in estimators used to update lower and upper bounds
on random variables that have yet to be integrated out.</p></li>
<li><p><strong>log_prob</strong> (<em>Tensor</em>) – Tensor of log probabilities.</p></li>
<li><p><strong>log_prob_extra</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Tensor of conditional log probabilities for the next random
variable. Used when integrating over an odd number of random variables.</p></li>
<li><p><strong>perm</strong> (<em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the MVNXPB solver instance for a fixed number of steps.</p>
<p>Calculates a bivariate conditional approximation to P(X in bounds), where
X ~ N(0, Σ). For details, see [Genz2016numerical] or <a class="reference internal" href="#trinh2015bivariate" id="id22"><span>[Trinh2015bivariate]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_steps</strong> (<em>int</em><em> | </em><em>None</em>) – </p></li>
<li><p><strong>eps</strong> (<em>float</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.select_pivot">
<span class="sig-name descname"><span class="pre">select_pivot</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.select_pivot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.select_pivot" title="Permalink to this definition">¶</a></dt>
<dd><p>GGE variable prioritization strategy from <a class="reference internal" href="#gibson1994monte" id="id23"><span>[Gibson1994monte]</span></a>.</p>
<p>Returns the index of the random variable least likely to satisfy its bounds
when conditioning on the previously integrated random variables <cite>X[:t - 1]</cite>
attaining the values of plug-in estimators <cite>y[:t - 1]</cite>. Equivalently,
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">argmin_{i</span> <span class="pre">=</span> <span class="pre">t,</span> <span class="pre">...,</span> <span class="pre">n}</span> <span class="pre">P(X[i]</span> <span class="pre">\in</span> <span class="pre">bounds[i]</span> <span class="pre">|</span> <span class="pre">X[:t-1]</span> <span class="pre">=</span> <span class="pre">y[:t</span> <span class="pre">-1]),</span>
<span class="pre">`</span></code>
where <cite>t</cite> denotes the current step.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>LongTensor</em> | None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.pivot_">
<span class="sig-name descname"><span class="pre">pivot_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pivot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.pivot_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.pivot_" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap random variables at <cite>pivot</cite> and <cite>step</cite> positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pivot</strong> (<em>LongTensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.concat">
<span class="sig-name descname"><span class="pre">concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.concat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.concat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a>) – </p></li>
<li><p><strong>dim</strong> (<em>int</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">sizes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.expand" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sizes</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.augment">
<span class="sig-name descname"><span class="pre">augment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">covariance_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_covariance_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disable_pivoting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_tries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.augment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.augment" title="Permalink to this definition">¶</a></dt>
<dd><p>Augment an <cite>n</cite>-dimensional MVNXPB instance to include <cite>m</cite> additional random
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>covariance_matrix</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>cross_covariance_matrix</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>disable_pivoting</strong> (<em>bool</em>) – </p></li>
<li><p><strong>jitter</strong> (<em>float</em><em> | </em><em>None</em>) – </p></li>
<li><p><strong>max_tries</strong> (<em>int</em><em> | </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.detach">
<span class="sig-name descname"><span class="pre">detach</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.detach"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.detach" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.clone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.clone" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.asdict">
<span class="sig-name descname"><span class="pre">asdict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.asdict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.asdict" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState" title="botorch.utils.probability.mvnxpb.mvnxpbState"><em>mvnxpbState</em></a></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.probability.truncated_multivariate_normal">
<span id="truncated-multivariate-normal-distribution"></span><h2>Truncated Multivariate Normal Distribution<a class="headerlink" href="#module-botorch.utils.probability.truncated_multivariate_normal" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.truncated_multivariate_normal.</span></span><span class="sig-name descname"><span class="pre">TruncatedMultivariateNormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariance_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_tril</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/truncated_multivariate_normal.html#TruncatedMultivariateNormal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">MultivariateNormal</span></code></p>
<p>Initializes an instance of a TruncatedMultivariateNormal distribution.</p>
<p>Let <cite>x ~ N(0, K)</cite> be an <cite>n</cite>-dimensional Gaussian random vector. This class
represents the distribution of the truncated Multivariate normal random vector
<cite>x | a &lt;= x &lt;= b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loc</strong> (<em>Tensor</em>) – A mean vector for the distribution, <cite>batch_shape x event_shape</cite>.</p></li>
<li><p><strong>covariance_matrix</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – Covariance matrix distribution parameter.</p></li>
<li><p><strong>precision_matrix</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – Inverse covariance matrix distribution parameter.</p></li>
<li><p><strong>scale_tril</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – Lower triangular, square-root covariance matrix distribution
parameter.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>batch_shape x event_shape x 2</cite> tensor of strictly increasing
bounds for <cite>x</cite> so that <cite>bounds[…, 0] &lt; bounds[…, 1]</cite> everywhere.</p></li>
<li><p><strong>solver</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a><em>]</em>) – A pre-solved MVNXPB instance used to approximate the log partition.</p></li>
<li><p><strong>sampler</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler" title="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler"><em>LinearEllipticalSliceSampler</em></a><em>]</em>) – A LinearEllipticalSliceSampler instance used for sample generation.</p></li>
<li><p><strong>validate_args</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – Optional argument to super().__init__.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_prob">
<span class="sig-name descname"><span class="pre">log_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/truncated_multivariate_normal.html#TruncatedMultivariateNormal.log_prob"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximates the true log probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.Size([])</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/truncated_multivariate_normal.html#TruncatedMultivariateNormal.rsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.rsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw samples from the Truncated Multivariate Normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sample_shape</strong> (<em>Size</em>) – The shape of the samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The (sample_shape x batch_shape x event_shape) tensor of samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_partition">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">log_partition</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_partition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.solver">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solver</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><span class="pre">MVNXPB</span></a></em><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.solver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.sampler">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sampler</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler" title="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler"><span class="pre">LinearEllipticalSliceSampler</span></a></em><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.sampler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/truncated_multivariate_normal.html#TruncatedMultivariateNormal.expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new distribution instance (or populates an existing instance
provided by a derived class) with batch dimensions expanded to
<cite>batch_shape</cite>. This method calls <code class="xref py py-class docutils literal notranslate"><span class="pre">expand</span></code> on
the distribution’s parameters. As such, this does not allocate new
memory for the expanded distribution instance. Additionally,
this does not repeat any args checking or parameter broadcasting in
<cite>__init__.py</cite>, when an instance is first created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_shape</strong> (<em>torch.Size</em>) – the desired expanded size.</p></li>
<li><p><strong>_instance</strong> (<a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal" title="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal"><em>TruncatedMultivariateNormal</em></a><em> | </em><em>None</em>) – new instance provided by subclasses that
need to override <cite>.expand</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New distribution instance with batch dimensions expanded to
<cite>batch_size</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal" title="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal"><em>TruncatedMultivariateNormal</em></a></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.probability.unified_skew_normal">
<span id="unified-skew-normal-distribution"></span><h2>Unified Skew Normal Distribution<a class="headerlink" href="#module-botorch.utils.probability.unified_skew_normal" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.unified_skew_normal.</span></span><span class="sig-name descname"><span class="pre">UnifiedSkewNormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trunc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_covariance_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/unified_skew_normal.html#UnifiedSkewNormal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></p>
<p>Unified Skew Normal distribution of <cite>Y | a &lt; X &lt; b</cite> for jointly Gaussian
random vectors <cite>X ∈ R^m</cite> and <cite>Y ∈ R^n</cite>.</p>
<p>Batch shapes <cite>trunc.batch_shape</cite> and <cite>gauss.batch_shape</cite> must be broadcastable.
Care should be taken when choosing <cite>trunc.batch_shape</cite>. When <cite>trunc</cite> is of lower
batch dimensionality than <cite>gauss</cite>, the user should consider expanding <cite>trunc</cite> to
hasten <cite>UnifiedSkewNormal.log_prob</cite>. In these cases, it is suggested that the
user invoke <cite>trunc.solver</cite> before calling <cite>trunc.expand</cite> to avoid paying for
multiple, identical solves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trunc</strong> (<a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal" title="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal"><em>TruncatedMultivariateNormal</em></a>) – Distribution of <cite>Z = (X | a &lt; X &lt; b) ∈ R^m</cite>.</p></li>
<li><p><strong>gauss</strong> (<em>MultivariateNormal</em>) – Distribution of <cite>Y ∈ R^n</cite>.</p></li>
<li><p><strong>cross_covariance_matrix</strong> (<em>Union</em><em>[</em><em>Tensor</em><em>, </em><em>LinearOperator</em><em>]</em>) – Cross-covariance <cite>Cov(X, Y) ∈ R^{m x n}</cite>.</p></li>
<li><p><strong>validate_args</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em>) – Optional argument to super().__init__.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.arg_constraints">
<span class="sig-name descname"><span class="pre">arg_constraints</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.arg_constraints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.log_prob">
<span class="sig-name descname"><span class="pre">log_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/unified_skew_normal.html#UnifiedSkewNormal.log_prob"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.log_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the log probability <cite>ln p(Y = value | a &lt; X &lt; b)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.Size([])</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/unified_skew_normal.html#UnifiedSkewNormal.rsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.rsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw samples from the Unified Skew Normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sample_shape</strong> (<em>Size</em>) – The shape of the samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The (sample_shape x batch_shape x event_shape) tensor of samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/unified_skew_normal.html#UnifiedSkewNormal.expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new distribution instance (or populates an existing instance
provided by a derived class) with batch dimensions expanded to
<cite>batch_shape</cite>. This method calls <code class="xref py py-class docutils literal notranslate"><span class="pre">expand</span></code> on
the distribution’s parameters. As such, this does not allocate new
memory for the expanded distribution instance. Additionally,
this does not repeat any args checking or parameter broadcasting in
<cite>__init__.py</cite>, when an instance is first created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_shape</strong> (<em>torch.Size</em>) – the desired expanded size.</p></li>
<li><p><strong>_instance</strong> (<a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal" title="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal"><em>UnifiedSkewNormal</em></a><em> | </em><em>None</em>) – new instance provided by subclasses that
need to override <cite>.expand</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New distribution instance with batch dimensions expanded to
<cite>batch_size</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal" title="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal"><em>UnifiedSkewNormal</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.covariance_matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">covariance_matrix</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.scale_tril">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale_tril</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.scale_tril" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.probability.bvn">
<span id="bivariate-normal-probabilities-and-statistics"></span><h2>Bivariate Normal Probabilities and Statistics<a class="headerlink" href="#module-botorch.utils.probability.bvn" title="Permalink to this heading">¶</a></h2>
<p>Methods for computing bivariate normal probabilities and statistics.</p>
<div class="citation-list" role="list">
<div class="citation" id="genz2004bvnt" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Genz2004bvnt<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a href="#id24" role="doc-backlink">1</a>,<a href="#id25" role="doc-backlink">2</a>,<a href="#id26" role="doc-backlink">3</a>)</span>
<p>A. Genz. Numerical computation of rectangular bivariate and trivariate normal and
t probabilities. Statistics and Computing, 2004.</p>
</div>
<div class="citation" id="muthen1990moments" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a href="#id27" role="doc-backlink">Muthen1990moments</a><span class="fn-bracket">]</span></span>
<p>B. Muthen. Moments of the censored and truncated bivariate normal distribution.
British Journal of Mathematical and Statistical Psychology, 1990.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.bvn.bvn">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.bvn.</span></span><span class="sig-name descname"><span class="pre">bvn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yu</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/bvn.html#bvn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.bvn.bvn" title="Permalink to this definition">¶</a></dt>
<dd><p>A function for computing bivariate normal probabilities.</p>
<p>Calculates <cite>P(xl &lt; x &lt; xu, yl &lt; y &lt; yu)</cite> where <cite>x</cite> and <cite>y</cite> are bivariate normal with
unit variance and correlation coefficient <cite>r</cite>. See Section 2.4 of <a class="reference internal" href="#genz2004bvnt" id="id24"><span>[Genz2004bvnt]</span></a>.</p>
<p>This method uses a sign flip trick to improve numerical performance. Many of <cite>bvnu`s
internal branches rely on evaluations `Phi(-bound)</cite>. For <cite>a &lt; b &lt; 0</cite>, the term
<cite>Phi(-a) - Phi(-b)</cite> goes to zero faster than <cite>Phi(b) - Phi(a)</cite> because
<cite>finfo(dtype).epsneg</cite> is typically much larger than <cite>finfo(dtype).tiny</cite>. In these
cases, flipping the sign can prevent situations where <cite>bvnu(…) - bvnu(…)</cite> would
otherwise be zero due to round-off error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>Tensor</em>) – Tensor of correlation coefficients.</p></li>
<li><p><strong>xl</strong> (<em>Tensor</em>) – Tensor of lower bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>yl</strong> (<em>Tensor</em>) – Tensor of lower bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>xu</strong> (<em>Tensor</em>) – Tensor of upper bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>yu</strong> (<em>Tensor</em>) – Tensor of upper bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tensor of probabilities <cite>P(xl &lt; x &lt; xu, yl &lt; y &lt; yu)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.bvn.bvnu">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.bvn.</span></span><span class="sig-name descname"><span class="pre">bvnu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/bvn.html#bvnu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.bvn.bvnu" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for <cite>P(x &gt; h, y &gt; k)</cite> where <cite>x</cite> and <cite>y</cite> are standard bivariate normal
random variables with correlation coefficient <cite>r</cite>. In <a class="reference internal" href="#genz2004bvnt" id="id25"><span>[Genz2004bvnt]</span></a>, this is (1)</p>
<blockquote>
<div><p><cite>L(h, k, r) = P(x &lt; -h, y &lt; -k) = 1/(a 2pi) int_{h}^{infty} int_{k}^{infty} f(x, y, r) dy dx,</cite></p>
</div></blockquote>
<p>where <cite>f(x, y, r) = e^{-1/(2a^2) (x^2 - 2rxy + y^2)}</cite> and <cite>a = (1 - r^2)^{1/2}</cite>.</p>
<p><a class="reference internal" href="#genz2004bvnt" id="id26"><span>[Genz2004bvnt]</span></a> report the following integation scheme incurs a maximum of 5e-16
error when run in double precision: if <cite>|r| &gt;= 0.925</cite>, use a 20-point quadrature
rule on a 5th order Taylor expansion; else, numerically integrate in polar
coordinates using no more than 20 quadrature points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>Tensor</em>) – Tensor of correlation coefficients.</p></li>
<li><p><strong>h</strong> (<em>Tensor</em>) – Tensor of negative upper bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>k</strong> (<em>Tensor</em>) – Tensor of negative upper bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of probabilities <cite>P(x &gt; h, y &gt; k)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.bvn.bvnmom">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.bvn.</span></span><span class="sig-name descname"><span class="pre">bvnmom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/bvn.html#bvnmom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.bvn.bvnmom" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the expected values of truncated, bivariate normal random variables.</p>
<p>Let <cite>x</cite> and <cite>y</cite> be a pair of standard bivariate normal random variables having
correlation <cite>r</cite>. This function computes <cite>E([x,y] | [xl,yl] &lt; [x,y] &lt; [xu,yu])</cite>.</p>
<p>Following <a class="reference internal" href="#muthen1990moments" id="id27"><span>[Muthen1990moments]</span></a> equations (4) and (5), we have</p>
<blockquote>
<div><p><cite>E(x | [xl, yl] &lt; [x, y] &lt; [xu, yu]) = Z^{-1} phi(xl) P(yl &lt; y &lt; yu | x=xl) - phi(xu) P(yl &lt; y &lt; yu | x=xu),</cite></p>
</div></blockquote>
<p>where <cite>Z = P([xl, yl] &lt; [x, y] &lt; [xu, yu])</cite> and <cite>phi</cite> is the standard normal PDF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>Tensor</em>) – Tensor of correlation coefficients.</p></li>
<li><p><strong>xl</strong> (<em>Tensor</em>) – Tensor of lower bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>xu</strong> (<em>Tensor</em>) – Tensor of upper bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>yl</strong> (<em>Tensor</em>) – Tensor of lower bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>yu</strong> (<em>Tensor</em>) – Tensor of upper bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>p</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Tensor of probabilities <cite>P(xl &lt; x &lt; xu, yl &lt; y &lt; yu)</cite>, same shape as <cite>r</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>E(x | [xl, yl] &lt; [x, y] &lt; [xu, yu])</cite> and
<cite>E(y | [xl, yl] &lt; [x, y] &lt; [xu, yu])</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tuple</em>[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.probability.lin_ess">
<span id="elliptic-slice-sampler-with-linear-constraints"></span><h2>Elliptic Slice Sampler with Linear Constraints<a class="headerlink" href="#module-botorch.utils.probability.lin_ess" title="Permalink to this heading">¶</a></h2>
<p>Linear Elliptical Slice Sampler.</p>
<p>References</p>
<div class="citation-list" role="list">
<div class="citation" id="gessner2020" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a href="#id28" role="doc-backlink">Gessner2020</a><span class="fn-bracket">]</span></span>
<p>A. Gessner, O. Kanjilal, and P. Hennig. Integrals over gaussians under
linear domain constraints. AISTATS 2020.</p>
</div>
</div>
<p>This implementation is based (with multiple changes / optimiations) on
the following implementations based on the algorithm in <a class="reference internal" href="#gessner2020" id="id28"><span>[Gessner2020]</span></a>:
- <a class="reference external" href="https://github.com/alpiges/LinConGauss">https://github.com/alpiges/LinConGauss</a>
- <a class="reference external" href="https://github.com/wjmaddox/pytorch_ess">https://github.com/wjmaddox/pytorch_ess</a></p>
<p>The implementation here differentiates itself from the original implementations with:
1) Support for fixed feature equality constraints.
2) Support for non-standard Normal distributions.
3) Numerical stability improvements, especially relevant for high-dimensional cases.</p>
<p>Notably, this implementation does not rely on an adaptive <cite>delta_theta</cite> parameter in
order to determine if two neighboring constraint intersection angles <cite>theta</cite> lead to a
change in the feasibility of the sample. This both simplifies the implementation and
makes it more robust to numerical imprecisions when two constraint intersection angles
are close to each other.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.lin_ess.</span></span><span class="sig-name descname"><span class="pre">LinearEllipticalSliceSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariance_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariance_root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_feasibility</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thinning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/lin_ess.html#LinearEllipticalSliceSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">PolytopeSampler</span></code></p>
<p>Linear Elliptical Slice Sampler.</p>
<p>Ideas:
- Add batch support, broadcasting over parallel chains.
- Optimize computations if possible, potentially with torch.compile.
- Extend fixed features constraint to general linear equality constraints.</p>
<p>Initialize LinearEllipticalSliceSampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Tensors <cite>(A, b)</cite> describing inequality constraints
<cite>A @ x &lt;= b</cite>, where <cite>A</cite> is an <cite>n_ineq_con x d</cite>-dim Tensor and <cite>b</cite> is
an <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite> the number of
inequalities and <cite>d</cite> the dimension of the sample space. If omitted,
must provide <cite>bounds</cite> instead.</p></li>
<li><p><strong>bounds</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>2 x d</cite>-dim tensor of box bounds. If omitted, must provide
<cite>inequality_constraints</cite> instead.</p></li>
<li><p><strong>interior_point</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>d x 1</cite>-dim Tensor presenting a point in the (relative)
interior of the polytope. If omitted, an interior point is determined
automatically by solving a Linear Program. Note: It is crucial that
the point lie in the interior of the feasible set (rather than on the
boundary), otherwise the sampler will produce invalid samples.</p></li>
<li><p><strong>fixed_indices</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – Integer list or <cite>d</cite>-dim Tensor representing the indices of
dimensions that are constrained to be fixed to the values specified in
the <cite>interior_point</cite>, which is required to be passed in conjunction with
<cite>fixed_indices</cite>.</p></li>
<li><p><strong>mean</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – The <cite>d x 1</cite>-dim mean of the MVN distribution (if omitted, use zero).</p></li>
<li><p><strong>covariance_matrix</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – The <cite>d x d</cite>-dim covariance matrix of the MVN
distribution (if omitted, use the identity).</p></li>
<li><p><strong>covariance_root</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – A <cite>d x d</cite>-dim root of the covariance matrix such that
covariance_root @ covariance_root.T = covariance_matrix. NOTE: This
matrix is assumed to be lower triangular.</p></li>
<li><p><strong>check_feasibility</strong> (<em>bool</em>) – If True, raise an error if the sampling results in an
infeasible sample. This creates some overhead and so is switched off
by default.</p></li>
<li><p><strong>burnin</strong> (<em>int</em>) – Number of samples to generate upon initialization to warm up the
sampler.</p></li>
<li><p><strong>thinning</strong> (<em>int</em>) – Number of samples to skip before returning a sample in <cite>draw</cite>.</p></li>
</ul>
</dd>
</dl>
<p>This sampler samples from a multivariante Normal <cite>N(mean, covariance_matrix)</cite>
subject to linear domain constraints <cite>A x &lt;= b</cite> (intersected with box bounds,
if provided).</p>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.lifetime_samples">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lifetime_samples</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.lifetime_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of samples generated by the sampler during its lifetime.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/lin_ess.html#LinearEllipticalSliceSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – The number of samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x d</cite>-dim tensor of <cite>n</cite> samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tuple</em>[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/lin_ess.html#LinearEllipticalSliceSampler.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.step" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a step, return the new sample, update the internal state.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>d x 1</cite>-dim sample from the domain.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.get_index_tensors">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.lin_ess.</span></span><span class="sig-name descname"><span class="pre">get_index_tensors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fixed_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/lin_ess.html#get_index_tensors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.lin_ess.get_index_tensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <cite>fixed_indices</cite> to a <cite>d</cite>-dim integral Tensor that is True at indices
that are contained in <cite>fixed_indices</cite> and False otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fixed_indices</strong> (<em>List</em><em>[</em><em>int</em><em>] </em><em>| </em><em>Tensor</em>) – A list or Tensoro of integer indices to fix.</p></li>
<li><p><strong>d</strong> (<em>int</em>) – The dimensionality of the Tensors to be indexed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tuple of integral Tensors partitioning [1, d] into indices that are fixed
(first tensor) and non-fixed (second tensor).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tuple</em>[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>
</section>
<section id="module-botorch.utils.probability.linalg">
<span id="linear-algebra-helpers"></span><h2>Linear Algebra Helpers<a class="headerlink" href="#module-botorch.utils.probability.linalg" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.block_matrix_concat">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.linalg.</span></span><span class="sig-name descname"><span class="pre">block_matrix_concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#block_matrix_concat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.block_matrix_concat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>blocks</strong> (<em>Sequence</em><em>[</em><em>Sequence</em><em>[</em><em>Tensor</em><em>]</em><em>]</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.augment_cholesky">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.linalg.</span></span><span class="sig-name descname"><span class="pre">augment_cholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Laa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kbb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#augment_cholesky"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.augment_cholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Cholesky factor of a block matrix <cite>K = [[Kaa, Kab], [Kba, Kbb]]</cite>
based on a precomputed Cholesky factor <cite>Kaa = Laa Laa^T</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Laa</strong> (<em>Tensor</em>) – Cholesky factor of K’s upper left block.</p></li>
<li><p><strong>Kbb</strong> (<em>Tensor</em>) – Lower-right block of K.</p></li>
<li><p><strong>Kba</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Lower-left block of K.</p></li>
<li><p><strong>Lba</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Precomputed solve <cite>Kba Laa^{-T}</cite>.</p></li>
<li><p><strong>jitter</strong> (<em>float</em><em> | </em><em>None</em>) – Optional nugget to be added to the diagonal of Kbb.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.linalg.</span></span><span class="sig-name descname"><span class="pre">PivotedCholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'int'</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'Tensor'</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'LongTensor'</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'Optional[Tensor]'</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_init</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'InitVar[bool]'</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>step</strong> (<em>int</em>) – </p></li>
<li><p><strong>tril</strong> (<em>Tensor</em>) – </p></li>
<li><p><strong>perm</strong> (<em>LongTensor</em>) – </p></li>
<li><p><strong>diag</strong> (<em>Optional</em><em>[</em><em>Tensor</em><em>]</em>) – </p></li>
<li><p><strong>validate_init</strong> (<em>InitVar</em><em>[</em><em>bool</em><em>]</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.step">
<span class="sig-name descname"><span class="pre">step</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.tril">
<span class="sig-name descname"><span class="pre">tril</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.tril" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.perm">
<span class="sig-name descname"><span class="pre">perm</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">LongTensor</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.perm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.diag">
<span class="sig-name descname"><span class="pre">diag</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.diag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.validate_init">
<span class="sig-name descname"><span class="pre">validate_init</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">InitVar</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.validate_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.update_">
<span class="sig-name descname"><span class="pre">update_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.update_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.update_" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a single matrix decomposition step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>eps</strong> (<em>float</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.pivot_">
<span class="sig-name descname"><span class="pre">pivot_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pivot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.pivot_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.pivot_" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pivot</strong> (<em>LongTensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">sizes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.expand" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sizes</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.concat">
<span class="sig-name descname"><span class="pre">concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.concat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.concat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a>) – </p></li>
<li><p><strong>dim</strong> (<em>int</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.detach">
<span class="sig-name descname"><span class="pre">detach</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.detach"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.detach" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a></p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.clone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.clone" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="module-botorch.utils.probability.utils">
<span id="probability-helpers"></span><h2>Probability Helpers<a class="headerlink" href="#module-botorch.utils.probability.utils" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.case_dispatcher">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">case_dispatcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cases</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#case_dispatcher"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.case_dispatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic implementation of a tensorized switching case statement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out</strong> (<em>Tensor</em>) – Tensor to which case outcomes are written.</p></li>
<li><p><strong>cases</strong> (<em>Iterable</em><em>[</em><em>Tuple</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>]</em><em>, </em><em>BoolTensor</em><em>]</em><em>, </em><em>Callable</em><em>[</em><em>[</em><em>BoolTensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em><em>]</em>) – Iterable of function pairs (pred, func), where <cite>mask=pred()</cite> specifies
whether <cite>func</cite> is applicable for each entry in <cite>out</cite>. Note that cases are
resolved first-come, first-serve.</p></li>
<li><p><strong>default</strong> (<em>Callable</em><em>[</em><em>[</em><em>BoolTensor</em><em>]</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – Optional <cite>func</cite> to which all unclaimed entries of <cite>out</cite> are dispatched.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.get_constants">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">get_constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#get_constants"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.get_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns scalar-valued Tensors containing each of the given constants.
Used to expedite tensor operations involving scalar arithmetic. Note that
the returned Tensors should not be modified in-place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Number</em><em> | </em><em>Iterator</em><em>[</em><em>Number</em><em>]</em>) – </p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – </p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em> | <em>Tuple</em>[<em>Tensor</em>, …]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.get_constants_like">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">get_constants_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#get_constants_like"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.get_constants_like" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Number</em><em> | </em><em>Iterator</em><em>[</em><em>Number</em><em>]</em>) – </p></li>
<li><p><strong>ref</strong> (<em>Tensor</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em> | <em>Iterator</em>[<em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.gen_positional_indices">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">gen_positional_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#gen_positional_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.gen_positional_indices" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>Size</em>) – </p></li>
<li><p><strong>dim</strong> (<em>int</em>) – </p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Iterator</em>[<em>LongTensor</em>]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.build_positional_indices">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">build_positional_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#build_positional_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.build_positional_indices" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>Size</em>) – </p></li>
<li><p><strong>dim</strong> (<em>int</em>) – </p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>LongTensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.leggauss">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">leggauss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#leggauss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.leggauss" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>int</em>) – </p></li>
<li><p><strong>tkwargs</strong> (<em>Any</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tuple</em>[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.ndtr">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">ndtr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#ndtr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.ndtr" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard normal CDF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.phi">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">phi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#phi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard normal PDF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_phi">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_phi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_phi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithm of standard normal pdf</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_ndtr">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_ndtr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_ndtr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_ndtr" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of log_ndtr that remedies problems of torch.special’s version
for large negative x, where the torch implementation yields Inf or NaN gradients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – An input tensor with dtype torch.float32 or torch.float64.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of values of the same type and shape as x containing log(ndtr(x)).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_erfc">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_erfc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_erfc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_erfc" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the logarithm of the complementary error function in a numerically
stable manner. The GitHub issue <a class="reference external" href="https://github.com/pytorch/pytorch/issues/31945">https://github.com/pytorch/pytorch/issues/31945</a>
tracks progress toward moving this feature into PyTorch in C++.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – An input tensor with dtype torch.float32 or torch.float64.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of values of the same type and shape as x containing log(erfc(x)).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_erfcx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_erfcx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_erfcx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_erfcx" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the logarithm of the complementary scaled error function in a
numerically stable manner. The GitHub issue tracks progress toward moving this
feature into PyTorch in C++: <a class="reference external" href="https://github.com/pytorch/pytorch/issues/31945">https://github.com/pytorch/pytorch/issues/31945</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – An input tensor with dtype torch.float32 or torch.float64.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of values of the same type and shape as x containing log(erfcx(x)).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.standard_normal_log_hazard">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">standard_normal_log_hazard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#standard_normal_log_hazard"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.standard_normal_log_hazard" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the logarithm of the hazard function of the standard normal
distribution, i.e. <cite>log(phi(x) / Phi(-x))</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – A tensor of any shape, with either float32 or float64 dtypes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of the same shape <cite>x</cite>, containing the values of the logarithm of the
hazard function evaluated at <cite>x</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_prob_normal_in">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_prob_normal_in</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_prob_normal_in"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_prob_normal_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the probability that a standard normal random variable takes a value
in [a, b], i.e. log(Phi(b) - Phi(a)), where Phi is the standard normal CDF.
Returns accurate values and permits numerically stable backward passes for inputs
in [-1e100, 1e100] for double precision and [-1e20, 1e20] for single precision.
In contrast, a naive approach is not numerically accurate beyond [-10, 10].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>) – Tensor of lower integration bounds of the Gaussian probability measure.</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – Tensor of upper integration bounds of the Gaussian probability measure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tensor of the log probabilities.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.swap_along_dim_">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">swap_along_dim_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#swap_along_dim_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.swap_along_dim_" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps Tensor slices in-place along dimension <cite>dim</cite>.</p>
<p>When passed as Tensors, <cite>i</cite> (and <cite>j</cite>) should be <cite>dim</cite>-dimensional tensors
with the same shape as <cite>values.shape[:dim]</cite>. The xception to this rule occurs
when <cite>dim=0</cite>, in which case <cite>i</cite> (and <cite>j</cite>) should be (at most) one-dimensional
when passed as a Tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Tensor</em>) – Tensor whose values are to be swapped.</p></li>
<li><p><strong>i</strong> (<em>int</em><em> | </em><em>LongTensor</em>) – Indices for slices along dimension <cite>dim</cite>.</p></li>
<li><p><strong>j</strong> (<em>int</em><em> | </em><em>LongTensor</em>) – Indices for slices along dimension <cite>dim</cite>.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of <cite>values</cite> along which to swap slices.</p></li>
<li><p><strong>buffer</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Optional buffer used internally to store copied values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The original <cite>values</cite> tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>
</section>
</section>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">BoTorch</a></h1>
<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="acquisition.html">botorch.acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">botorch.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="generation.html">botorch.generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="posteriors.html">botorch.posteriors</a></li>
<li class="toctree-l1"><a class="reference internal" href="optim.html">botorch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="fit.html">botorch.fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">botorch.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="cross_validation.html">botorch.cross_validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="settings.html">botorch.settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">botorch.logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="test_functions.html">botorch.test_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="exceptions.html">botorch.exceptions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">botorch.utils</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="index.html">Documentation overview</a><ul>
<li>Previous: <a href="exceptions.html" title="previous chapter">botorch.exceptions</a></li>
</ul></li>
</ul>
</div>
<div id="searchbox" role="search" style="display: none">
<h3 id="searchlabel">Quick search</h3>
<div class="searchformwrapper">
<form action="search.html" class="search" method="get">
<input aria-labelledby="searchlabel" autocapitalize="off" autocomplete="off" autocorrect="off" name="q" spellcheck="false" type="text"/>
<input type="submit" value="Go"/>
</form>
</div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
</div>
</div>
<div class="clearer"></div>
</div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/v/latest/" class="nav-home"><img src="/v/latest/img/botorch.png" alt="BoTorch" width="66" height="58"/></a><div class="footerSection"><h5>Docs</h5><a href="/v/latest/docs/introduction">Introduction</a><a href="/v/latest/docs/getting_started">Getting Started</a><a href="/v/latest/tutorials/">Tutorials</a><a href="/v/latest/api/">API Reference</a><a href="https://arxiv.org/abs/1910.06403">Paper</a></div><div class="footerSection"><h5>Legal</h5><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noreferrer noopener">Privacy</a><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noreferrer noopener">Terms</a></div><div class="footerSection"><h5>Social</h5><div class="social"><a class="github-button" href="https://github.com/pytorch/botorch" data-count-href="https://github.com/pytorch/botorch/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star BoTorch on GitHub">botorch</a></div></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/v/latest/img/oss_logo.png" alt="Meta Open Source" width="300" height="25"/></a><section class="copyright"> Copyright © 2023 Meta Platforms, Inc</section><script>
            (function() {
              var BAD_BASE = '/botorch/';
              if (window.location.origin !== 'https://botorch.org') {
                var pathname = window.location.pathname;
                var newPathname = pathname.slice(pathname.indexOf(BAD_BASE) === 0 ? BAD_BASE.length : 1);
                var newLocation = 'https://botorch.org/v/latest/' + newPathname;
                console.log('redirecting to ' + newLocation);
                window.location.href = newLocation;
              }
            })();
          </script></footer></div></body></html>